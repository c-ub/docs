<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.51">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/img/1.jpg"><title>第7节 高质量的Makefile | 你好</title><meta name="description" content="链学社致力于打造出区块链去中心化的学习平台">
    <link rel="modulepreload" href="/assets/app.9967c189.js"><link rel="modulepreload" href="/assets/7.html.e0dcc1dd.js"><link rel="modulepreload" href="/assets/7.html.af5be859.js"><link rel="prefetch" href="/assets/index.html.a1393c4c.js"><link rel="prefetch" href="/assets/index.html.e3e54846.js"><link rel="prefetch" href="/assets/1.html.22289593.js"><link rel="prefetch" href="/assets/10.html.fcccc2ff.js"><link rel="prefetch" href="/assets/11.html.aac1a3bd.js"><link rel="prefetch" href="/assets/12.html.b371710f.js"><link rel="prefetch" href="/assets/13.html.4c3ede3b.js"><link rel="prefetch" href="/assets/14.html.a5ba315e.js"><link rel="prefetch" href="/assets/15.html.1580a958.js"><link rel="prefetch" href="/assets/16.html.a8349d9b.js"><link rel="prefetch" href="/assets/17.html.429cbcbd.js"><link rel="prefetch" href="/assets/18.html.d15c806b.js"><link rel="prefetch" href="/assets/19.html.070f0886.js"><link rel="prefetch" href="/assets/2.html.99975564.js"><link rel="prefetch" href="/assets/20.html.93b19902.js"><link rel="prefetch" href="/assets/21.html.cf7d1b5d.js"><link rel="prefetch" href="/assets/22.html.db4afbd7.js"><link rel="prefetch" href="/assets/23.html.a1e62360.js"><link rel="prefetch" href="/assets/24.html.21dea561.js"><link rel="prefetch" href="/assets/25.html.49b862c4.js"><link rel="prefetch" href="/assets/26.html.36989258.js"><link rel="prefetch" href="/assets/27.html.571b1d4e.js"><link rel="prefetch" href="/assets/28.html.4b7e2a2b.js"><link rel="prefetch" href="/assets/29.html.251aabee.js"><link rel="prefetch" href="/assets/3.html.3f00f3d0.js"><link rel="prefetch" href="/assets/30.html.225d86b8.js"><link rel="prefetch" href="/assets/31.html.9f14dfc5.js"><link rel="prefetch" href="/assets/32.html.8ac1706b.js"><link rel="prefetch" href="/assets/33.html.1e0dfe99.js"><link rel="prefetch" href="/assets/34.html.f2444c6f.js"><link rel="prefetch" href="/assets/35.html.a4049674.js"><link rel="prefetch" href="/assets/36.html.d4fcf351.js"><link rel="prefetch" href="/assets/37.html.e29eb8b4.js"><link rel="prefetch" href="/assets/38.html.195d22cf.js"><link rel="prefetch" href="/assets/39.html.90f09380.js"><link rel="prefetch" href="/assets/4.html.be4bc5b5.js"><link rel="prefetch" href="/assets/40.html.45d7a4dc.js"><link rel="prefetch" href="/assets/41.html.e3a2ebf7.js"><link rel="prefetch" href="/assets/42.html.2d4c045c.js"><link rel="prefetch" href="/assets/43.html.647962a9.js"><link rel="prefetch" href="/assets/44.html.804b2ebc.js"><link rel="prefetch" href="/assets/45.html.ecd5924e.js"><link rel="prefetch" href="/assets/46.html.f0df9beb.js"><link rel="prefetch" href="/assets/47.html.69252181.js"><link rel="prefetch" href="/assets/48.html.8df3099d.js"><link rel="prefetch" href="/assets/49.html.bbcbb6ca.js"><link rel="prefetch" href="/assets/5.html.8fa1df64.js"><link rel="prefetch" href="/assets/50.html.88a6df7a.js"><link rel="prefetch" href="/assets/51.html.2cc2cde7.js"><link rel="prefetch" href="/assets/52.html.8f10d639.js"><link rel="prefetch" href="/assets/53.html.87d57c98.js"><link rel="prefetch" href="/assets/54.html.3c986351.js"><link rel="prefetch" href="/assets/55.html.ef79ab9d.js"><link rel="prefetch" href="/assets/56.html.47391418.js"><link rel="prefetch" href="/assets/57.html.ed714ef8.js"><link rel="prefetch" href="/assets/58.html.e45a8f1a.js"><link rel="prefetch" href="/assets/59.html.a4ef2b6b.js"><link rel="prefetch" href="/assets/6.html.222cdccc.js"><link rel="prefetch" href="/assets/60.html.aa3091f2.js"><link rel="prefetch" href="/assets/61.html.d34e05ef.js"><link rel="prefetch" href="/assets/62.html.73c09267.js"><link rel="prefetch" href="/assets/63.html.ee77d345.js"><link rel="prefetch" href="/assets/64.html.e6870d98.js"><link rel="prefetch" href="/assets/65.html.4803352d.js"><link rel="prefetch" href="/assets/66.html.5f7f7cf5.js"><link rel="prefetch" href="/assets/67.html.1dda677a.js"><link rel="prefetch" href="/assets/68.html.46c4b431.js"><link rel="prefetch" href="/assets/69.html.01202045.js"><link rel="prefetch" href="/assets/70.html.698119d7.js"><link rel="prefetch" href="/assets/71.html.bca58bd1.js"><link rel="prefetch" href="/assets/72.html.0c495f64.js"><link rel="prefetch" href="/assets/73.html.1b1da238.js"><link rel="prefetch" href="/assets/74.html.5790a036.js"><link rel="prefetch" href="/assets/75.html.c0efadfb.js"><link rel="prefetch" href="/assets/76.html.80873dd0.js"><link rel="prefetch" href="/assets/77.html.bd454470.js"><link rel="prefetch" href="/assets/78.html.3610e426.js"><link rel="prefetch" href="/assets/79.html.a3fa3730.js"><link rel="prefetch" href="/assets/8.html.ddecb60c.js"><link rel="prefetch" href="/assets/80.html.ca6615ee.js"><link rel="prefetch" href="/assets/81.html.3ec6cf08.js"><link rel="prefetch" href="/assets/82.html.0c2a9c61.js"><link rel="prefetch" href="/assets/83.html.944f8804.js"><link rel="prefetch" href="/assets/84.html.275503f9.js"><link rel="prefetch" href="/assets/85.html.3a401355.js"><link rel="prefetch" href="/assets/86.html.09d84ac5.js"><link rel="prefetch" href="/assets/87.html.01ce4b91.js"><link rel="prefetch" href="/assets/88.html.17f7c6ee.js"><link rel="prefetch" href="/assets/89.html.564a9562.js"><link rel="prefetch" href="/assets/9.html.37eb122c.js"><link rel="prefetch" href="/assets/90.html.cf98daa9.js"><link rel="prefetch" href="/assets/91.html.43673b0c.js"><link rel="prefetch" href="/assets/92.html.4f001ff0.js"><link rel="prefetch" href="/assets/93.html.788d1091.js"><link rel="prefetch" href="/assets/94.html.99533281.js"><link rel="prefetch" href="/assets/95.html.4730f1df.js"><link rel="prefetch" href="/assets/96.html.563b0639.js"><link rel="prefetch" href="/assets/97.html.0597d140.js"><link rel="prefetch" href="/assets/98.html.2ab04005.js"><link rel="prefetch" href="/assets/99.html.4e64dae3.js"><link rel="prefetch" href="/assets/项目管理从理论到实践.html.6b900c97.js"><link rel="prefetch" href="/assets/404.html.c3e557d0.js"><link rel="prefetch" href="/assets/index.html.a716480a.js"><link rel="prefetch" href="/assets/index.html.c089bcfe.js"><link rel="prefetch" href="/assets/1.html.96c1b483.js"><link rel="prefetch" href="/assets/10.html.70df1453.js"><link rel="prefetch" href="/assets/11.html.a85b103a.js"><link rel="prefetch" href="/assets/12.html.0ef42857.js"><link rel="prefetch" href="/assets/13.html.1f81c8e2.js"><link rel="prefetch" href="/assets/14.html.c359f487.js"><link rel="prefetch" href="/assets/15.html.f1b4dadb.js"><link rel="prefetch" href="/assets/16.html.79d50df3.js"><link rel="prefetch" href="/assets/17.html.40ce0fe6.js"><link rel="prefetch" href="/assets/18.html.4e0ae6fa.js"><link rel="prefetch" href="/assets/19.html.8788756f.js"><link rel="prefetch" href="/assets/2.html.f329a49c.js"><link rel="prefetch" href="/assets/20.html.4a956a1c.js"><link rel="prefetch" href="/assets/21.html.3f94d17c.js"><link rel="prefetch" href="/assets/22.html.5053b9b1.js"><link rel="prefetch" href="/assets/23.html.8be33fb3.js"><link rel="prefetch" href="/assets/24.html.bbeadec5.js"><link rel="prefetch" href="/assets/25.html.fe2f9e6a.js"><link rel="prefetch" href="/assets/26.html.fc1b153f.js"><link rel="prefetch" href="/assets/27.html.5337558f.js"><link rel="prefetch" href="/assets/28.html.5462b281.js"><link rel="prefetch" href="/assets/29.html.ef61bbec.js"><link rel="prefetch" href="/assets/3.html.bf234322.js"><link rel="prefetch" href="/assets/30.html.0a5d70b0.js"><link rel="prefetch" href="/assets/31.html.ebde0fef.js"><link rel="prefetch" href="/assets/32.html.6aae646d.js"><link rel="prefetch" href="/assets/33.html.e48da599.js"><link rel="prefetch" href="/assets/34.html.f4bb5633.js"><link rel="prefetch" href="/assets/35.html.e963c197.js"><link rel="prefetch" href="/assets/36.html.5c9f4e1e.js"><link rel="prefetch" href="/assets/37.html.bc9a6296.js"><link rel="prefetch" href="/assets/38.html.e338e385.js"><link rel="prefetch" href="/assets/39.html.7e20dff2.js"><link rel="prefetch" href="/assets/4.html.276640c7.js"><link rel="prefetch" href="/assets/40.html.9c106b7a.js"><link rel="prefetch" href="/assets/41.html.168b7905.js"><link rel="prefetch" href="/assets/42.html.529356d0.js"><link rel="prefetch" href="/assets/43.html.481a8931.js"><link rel="prefetch" href="/assets/44.html.967f15b5.js"><link rel="prefetch" href="/assets/45.html.fcb4112e.js"><link rel="prefetch" href="/assets/46.html.bc42d448.js"><link rel="prefetch" href="/assets/47.html.c114ab47.js"><link rel="prefetch" href="/assets/48.html.05bf051d.js"><link rel="prefetch" href="/assets/49.html.8a079965.js"><link rel="prefetch" href="/assets/5.html.97bda10f.js"><link rel="prefetch" href="/assets/50.html.0f921e42.js"><link rel="prefetch" href="/assets/51.html.d48cb7de.js"><link rel="prefetch" href="/assets/52.html.e4e46567.js"><link rel="prefetch" href="/assets/53.html.54cefd27.js"><link rel="prefetch" href="/assets/54.html.fdf640a1.js"><link rel="prefetch" href="/assets/55.html.b19c799a.js"><link rel="prefetch" href="/assets/56.html.43da74bc.js"><link rel="prefetch" href="/assets/57.html.69632d1b.js"><link rel="prefetch" href="/assets/58.html.f5b4e3f3.js"><link rel="prefetch" href="/assets/59.html.25ecce2f.js"><link rel="prefetch" href="/assets/6.html.e5b8fe57.js"><link rel="prefetch" href="/assets/60.html.db1ec12a.js"><link rel="prefetch" href="/assets/61.html.9a7ab3dc.js"><link rel="prefetch" href="/assets/62.html.50e959f0.js"><link rel="prefetch" href="/assets/63.html.3018c48d.js"><link rel="prefetch" href="/assets/64.html.c3f1e1db.js"><link rel="prefetch" href="/assets/65.html.d2ca4759.js"><link rel="prefetch" href="/assets/66.html.a742a77e.js"><link rel="prefetch" href="/assets/67.html.1eddb882.js"><link rel="prefetch" href="/assets/68.html.d999abb5.js"><link rel="prefetch" href="/assets/69.html.bfef55ae.js"><link rel="prefetch" href="/assets/70.html.a56bd111.js"><link rel="prefetch" href="/assets/71.html.0dc0dbb6.js"><link rel="prefetch" href="/assets/72.html.4b8d08dd.js"><link rel="prefetch" href="/assets/73.html.be971ead.js"><link rel="prefetch" href="/assets/74.html.9f9ddcf6.js"><link rel="prefetch" href="/assets/75.html.f0312169.js"><link rel="prefetch" href="/assets/76.html.a48d8cc2.js"><link rel="prefetch" href="/assets/77.html.e20640c8.js"><link rel="prefetch" href="/assets/78.html.0370074f.js"><link rel="prefetch" href="/assets/79.html.8564ea9c.js"><link rel="prefetch" href="/assets/8.html.d0817860.js"><link rel="prefetch" href="/assets/80.html.e7246294.js"><link rel="prefetch" href="/assets/81.html.cb37703e.js"><link rel="prefetch" href="/assets/82.html.ac0663c4.js"><link rel="prefetch" href="/assets/83.html.fa76c17d.js"><link rel="prefetch" href="/assets/84.html.4e2cc728.js"><link rel="prefetch" href="/assets/85.html.dc517fe3.js"><link rel="prefetch" href="/assets/86.html.0a418a90.js"><link rel="prefetch" href="/assets/87.html.e13ae7b2.js"><link rel="prefetch" href="/assets/88.html.94185858.js"><link rel="prefetch" href="/assets/89.html.b9178319.js"><link rel="prefetch" href="/assets/9.html.7ed4bc7b.js"><link rel="prefetch" href="/assets/90.html.8fecf4cc.js"><link rel="prefetch" href="/assets/91.html.f2aab256.js"><link rel="prefetch" href="/assets/92.html.92d20a97.js"><link rel="prefetch" href="/assets/93.html.60aee91c.js"><link rel="prefetch" href="/assets/94.html.98e17b8e.js"><link rel="prefetch" href="/assets/95.html.0d8f773c.js"><link rel="prefetch" href="/assets/96.html.9f0e1107.js"><link rel="prefetch" href="/assets/97.html.bb6d8d92.js"><link rel="prefetch" href="/assets/98.html.83788c50.js"><link rel="prefetch" href="/assets/99.html.b083ab4c.js"><link rel="prefetch" href="/assets/项目管理从理论到实践.html.14b72e37.js"><link rel="prefetch" href="/assets/404.html.c06d2c49.js">
    <link rel="stylesheet" href="/assets/style.03848e77.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="切换侧边栏" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name can-hide">你好</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="🤵关于我"><span class="title">🤵关于我</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="🤵关于我"><span class="title">🤵关于我</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://github.com/cubxxw/awesome-cs-cloudnative-blockchain" rel="noopener noreferrer" target="_blank" aria-label="Github仓库"><!--[--><!--]--> Github仓库 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="http://nsddd.top" rel="noopener noreferrer" target="_blank" aria-label="我的博客"><!--[--><!--]--> 我的博客 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://www.zhihu.com/people/3293172751" rel="noopener noreferrer" target="_blank" aria-label="知乎"><!--[--><!--]--> 知乎 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://github.com/kubecub/" rel="noopener noreferrer" target="_blank" aria-label="⛓️链学社组织"><!--[--><!--]--> ⛓️链学社组织 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a href="/" class="" aria-label="🏠首页"><!--[--><!--]--> 🏠首页 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://docker.nsddd.top/" rel="noopener noreferrer" target="_blank" aria-label="🐋docker文档"><!--[--><!--]--> 🐋docker文档 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="📚go文档"><span class="title">📚go文档</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="📚go文档"><span class="title">📚go文档</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/projec/" class="" aria-label="🔥 K8s-Iam 项目"><!--[--><!--]--> 🔥 K8s-Iam 项目 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/k8s/" class="" aria-label="🔥 k8s 教程"><!--[--><!--]--> 🔥 k8s 教程 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/k8s-iam/" class="" aria-label="🔥 iam 教程"><!--[--><!--]--> 🔥 iam 教程 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/kubecub/docs" rel="noopener noreferrer" target="_blank" aria-label="查看源码"><!--[--><!--]--> 查看源码 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="切换颜色模式"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><div id="docsearch-container"></div></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="🤵关于我"><span class="title">🤵关于我</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="🤵关于我"><span class="title">🤵关于我</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://github.com/cubxxw/awesome-cs-cloudnative-blockchain" rel="noopener noreferrer" target="_blank" aria-label="Github仓库"><!--[--><!--]--> Github仓库 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="http://nsddd.top" rel="noopener noreferrer" target="_blank" aria-label="我的博客"><!--[--><!--]--> 我的博客 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://www.zhihu.com/people/3293172751" rel="noopener noreferrer" target="_blank" aria-label="知乎"><!--[--><!--]--> 知乎 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://github.com/kubecub/" rel="noopener noreferrer" target="_blank" aria-label="⛓️链学社组织"><!--[--><!--]--> ⛓️链学社组织 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a href="/" class="" aria-label="🏠首页"><!--[--><!--]--> 🏠首页 <!--[--><!--]--></a></div><div class="navbar-item"><a class="external-link" href="https://docker.nsddd.top/" rel="noopener noreferrer" target="_blank" aria-label="🐋docker文档"><!--[--><!--]--> 🐋docker文档 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="📚go文档"><span class="title">📚go文档</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="📚go文档"><span class="title">📚go文档</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/projec/" class="" aria-label="🔥 K8s-Iam 项目"><!--[--><!--]--> 🔥 K8s-Iam 项目 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/k8s/" class="" aria-label="🔥 k8s 教程"><!--[--><!--]--> 🔥 k8s 教程 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/k8s-iam/" class="" aria-label="🔥 iam 教程"><!--[--><!--]--> 🔥 iam 教程 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/kubecub/docs" rel="noopener noreferrer" target="_blank" aria-label="查看源码"><!--[--><!--]--> 查看源码 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/" class="sidebar-item sidebar-heading" aria-label="🏠回到主页"><!--[--><!--]--> 🏠回到主页 <!--[--><!--]--></a><!----></li><li><p tabindex="0" class="sidebar-item sidebar-heading active">🔥 Go语言基础篇 <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a href="/iam/projects/1.html" class="sidebar-item" aria-label="第1节 IAM项目介绍"><!--[--><!--]--> 第1节 IAM项目介绍 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/2.html" class="sidebar-item" aria-label="第2节 IAM项目部署"><!--[--><!--]--> 第2节 IAM项目部署 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/3.html" class="sidebar-item" aria-label="第3节 设计规范"><!--[--><!--]--> 第3节 设计规范 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/4.html" class="sidebar-item" aria-label="第4节 Go语言项目设计"><!--[--><!--]--> 第4节 Go语言项目设计 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/5.html" class="sidebar-item" aria-label="第5节 设计并写出优雅的Go语言项目"><!--[--><!--]--> 第5节 设计并写出优雅的Go语言项目 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/6.html" class="sidebar-item" aria-label="第6节 API 风格设计"><!--[--><!--]--> 第6节 API 风格设计 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/iam/projects/7.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="第7节 高质量的Makefile"><!--[--><!--]--> 第7节 高质量的Makefile <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/iam/projects/7.html#低质量的makefile" class="router-link-active router-link-exact-active sidebar-item" aria-label="低质量的makefile"><!--[--><!--]--> 低质量的makefile <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/iam/projects/7.html#makefile-如何工作" class="router-link-active router-link-exact-active sidebar-item" aria-label="makefile 如何工作"><!--[--><!--]--> makefile 如何工作 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/iam/projects/7.html#熟练makefile语法" class="router-link-active router-link-exact-active sidebar-item" aria-label="熟练makefile语法"><!--[--><!--]--> 熟练makefile语法 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/iam/projects/7.html#设计makefile结构" class="router-link-active router-link-exact-active sidebar-item" aria-label="设计Makefile结构"><!--[--><!--]--> 设计Makefile结构 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/iam/projects/7.html#掌握-makefile-编写技巧" class="router-link-active router-link-exact-active sidebar-item" aria-label="掌握 Makefile 编写技巧"><!--[--><!--]--> 掌握 Makefile 编写技巧 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/iam/projects/7.html#makefile-多线程" class="router-link-active router-link-exact-active sidebar-item" aria-label="Makefile 多线程"><!--[--><!--]--> Makefile 多线程 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/iam/projects/7.html#makefile-参数" class="router-link-active router-link-exact-active sidebar-item" aria-label="Makefile 参数"><!--[--><!--]--> Makefile 参数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/iam/projects/7.html#补充-makefile-go语言交叉编译" class="router-link-active router-link-exact-active sidebar-item" aria-label="补充：Makefile Go语言交叉编译"><!--[--><!--]--> 补充：Makefile Go语言交叉编译 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/iam/projects/7.html#总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="总结"><!--[--><!--]--> 总结 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/iam/projects/7.html#end-链接" class="router-link-active router-link-exact-active sidebar-item" aria-label="END 链接"><!--[--><!--]--> END 链接 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a href="/iam/projects/8.html" class="sidebar-item" aria-label="第8节 IAM 项目如何进行研发流程管理"><!--[--><!--]--> 第8节 IAM 项目如何进行研发流程管理 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/9.html" class="sidebar-item" aria-label="第9节 静态代码检测"><!--[--><!--]--> 第9节 静态代码检测 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/10.html" class="sidebar-item" aria-label="第10节 如何生成 Swagger API 文档"><!--[--><!--]--> 第10节 如何生成 Swagger API 文档 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/11.html" class="sidebar-item" aria-label="第11节 设计一套科学的错误码"><!--[--><!--]--> 第11节 设计一套科学的错误码 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/12.html" class="sidebar-item" aria-label="第12节 记录和设计日志"><!--[--><!--]--> 第12节 记录和设计日志 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/13.html" class="sidebar-item" aria-label="第13节  从 0 编写一个日志包"><!--[--><!--]--> 第13节  从 0 编写一个日志包 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/14.html" class="sidebar-item" aria-label="第14节 Pflag、Viper、Cobra 核心功能介绍"><!--[--><!--]--> 第14节 Pflag、Viper、Cobra 核心功能介绍 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/15.html" class="sidebar-item" aria-label="第15节 如何构建一个优秀的企业应用框架"><!--[--><!--]--> 第15节 如何构建一个优秀的企业应用框架 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/16.html" class="sidebar-item" aria-label="第16节 Gin 框架"><!--[--><!--]--> 第16节 Gin 框架 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/17.html" class="sidebar-item" aria-label="第17节 认证机制：应用程序如何进行访问认证？"><!--[--><!--]--> 第17节 认证机制：应用程序如何进行访问认证？ <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/18.html" class="sidebar-item" aria-label="第18节 IAM 项目认证"><!--[--><!--]--> 第18节 IAM 项目认证 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/19.html" class="sidebar-item" aria-label="第19节 权限模型：5大权限模型是如何进行资源授权的？"><!--[--><!--]--> 第19节 权限模型：5大权限模型是如何进行资源授权的？ <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/20.html" class="sidebar-item" aria-label="第20节 控制流（上）：通过iam-apiserver设计，看Web服务的构建"><!--[--><!--]--> 第20节 控制流（上）：通过iam-apiserver设计，看Web服务的构建 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/21.html" class="sidebar-item" aria-label="第21节 控制流（下）：iam-apiserver服务核心功能实现讲解"><!--[--><!--]--> 第21节 控制流（下）：iam-apiserver服务核心功能实现讲解 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/22.html" class="sidebar-item" aria-label="第22节 ORM：CURD 神器 GORM 包介绍及实战"><!--[--><!--]--> 第22节 ORM：CURD 神器 GORM 包介绍及实战 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/23.html" class="sidebar-item" aria-label="第23节 数据流：通过iam-authz-server设计，看数据流服务的设计"><!--[--><!--]--> 第23节 数据流：通过iam-authz-server设计，看数据流服务的设计 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/24.html" class="sidebar-item" aria-label="第24节 数据处理：如何高效处理应用程序产生的数据？"><!--[--><!--]--> 第24节 数据处理：如何高效处理应用程序产生的数据？ <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/25.html" class="sidebar-item" aria-label="第25节  SDK 设计（上）：如何设计出一个优秀的 Go SDK？"><!--[--><!--]--> 第25节  SDK 设计（上）：如何设计出一个优秀的 Go SDK？ <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/26.html" class="sidebar-item" aria-label="第26节  SDK 设计（下）：IAM项目Go SDK设计和实现"><!--[--><!--]--> 第26节  SDK 设计（下）：IAM项目Go SDK设计和实现 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/27.html" class="sidebar-item" aria-label="第27节 效率神器：如何设计和实现一个命令行客户端工具？"><!--[--><!--]--> 第27节 效率神器：如何设计和实现一个命令行客户端工具？ <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/28.html" class="sidebar-item" aria-label="第28节 代码测试（上）：如何编写 Go 语言单元测试和性能测试用例？"><!--[--><!--]--> 第28节 代码测试（上）：如何编写 Go 语言单元测试和性能测试用例？ <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/29.html" class="sidebar-item" aria-label="第29节 代码测试（下）：Go 语言其他测试类型及 IAM 测试介绍"><!--[--><!--]--> 第29节 代码测试（下）：Go 语言其他测试类型及 IAM 测试介绍 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/30.html" class="sidebar-item" aria-label="第30节 性能分析（上）：如何分析 Go 语言代码的性能？"><!--[--><!--]--> 第30节 性能分析（上）：如何分析 Go 语言代码的性能？ <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/31.html" class="sidebar-item" aria-label="第31节 性能分析（下）：API Server性能测试和调优实战"><!--[--><!--]--> 第31节 性能分析（下）：API Server性能测试和调优实战 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/32.html" class="sidebar-item" aria-label="第32节 软件部署实战（上）：部署方案及负载均衡、高可用组件介绍"><!--[--><!--]--> 第32节 软件部署实战（上）：部署方案及负载均衡、高可用组件介绍 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/33.html" class="sidebar-item" aria-label="第33节 软件部署实战（中）：IAM 系统生产环境部署实战"><!--[--><!--]--> 第33节 软件部署实战（中）：IAM 系统生产环境部署实战 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/34.html" class="sidebar-item" aria-label="第34节 软件部署实战（下）：IAM系统安全加固、水平扩缩容实战"><!--[--><!--]--> 第34节 软件部署实战（下）：IAM系统安全加固、水平扩缩容实战 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/35.html" class="sidebar-item" aria-label="第35节 技术演进（上）：虚拟化技术演进之路"><!--[--><!--]--> 第35节 技术演进（上）：虚拟化技术演进之路 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/36.html" class="sidebar-item" aria-label="第36节 技术演进（下）：软件架构和应用生命周期技术演进之路"><!--[--><!--]--> 第36节 技术演进（下）：软件架构和应用生命周期技术演进之路 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/37.html" class="sidebar-item" aria-label="第37节 基于Kubernetes的云原生架构设计"><!--[--><!--]--> 第37节 基于Kubernetes的云原生架构设计 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/38.html" class="sidebar-item" aria-label="第38节 如何制作Docker镜像？"><!--[--><!--]--> 第38节 如何制作Docker镜像？ <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/39.html" class="sidebar-item" aria-label="第39节 如何编写Kubernetes资源定义文件？"><!--[--><!--]--> 第39节 如何编写Kubernetes资源定义文件？ <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/40.html" class="sidebar-item" aria-label="第40节 IAM 容器化部署实战"><!--[--><!--]--> 第40节 IAM 容器化部署实战 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/41.html" class="sidebar-item" aria-label="第41节 服务编排（上）：Helm服务编排基础知识"><!--[--><!--]--> 第41节 服务编排（上）：Helm服务编排基础知识 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/42.html" class="sidebar-item" aria-label="第42节 服务编排（下）：基于Helm的服务编排部署实战"><!--[--><!--]--> 第42节 服务编排（下）：基于Helm的服务编排部署实战 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/43.html" class="sidebar-item" aria-label="第43节 基于 GitHub Actions 的 CI 实战"><!--[--><!--]--> 第43节 基于 GitHub Actions 的 CI 实战 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/44.html" class="sidebar-item" aria-label="第44节 可直接套用的 Go 编码规范"><!--[--><!--]--> 第44节 可直接套用的 Go 编码规范 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/45.html" class="sidebar-item" aria-label="第45节 Go Modules依赖包管理全讲"><!--[--><!--]--> 第45节 Go Modules依赖包管理全讲 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/46.html" class="sidebar-item" aria-label="第46节 IAM排障指南"><!--[--><!--]--> 第46节 IAM排障指南 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/47.html" class="sidebar-item" aria-label="第47节"><!--[--><!--]--> 第47节 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/48.html" class="sidebar-item" aria-label="第48节 分布式系统设计"><!--[--><!--]--> 第48节 分布式系统设计 <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/49.html" class="sidebar-item" aria-label="第49节 如何从小白进阶成 Go 语言专家？"><!--[--><!--]--> 第49节 如何从小白进阶成 Go 语言专家？ <!--[--><!--]--></a><!----></li><li><a href="/iam/projects/50.html" class="sidebar-item" aria-label="第50节"><!--[--><!--]--> 第50节 <!--[--><!--]--></a><!----></li><li><a class="external-link sidebar-item" href="https://nsddd.top/archives/contributors" rel="noopener noreferrer" target="_blank" aria-label="💝如何参与贡献？"><!--[--><!--]--> 💝如何参与贡献？ <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><ul><li><a href="https://github.com/cubxxw/iam" target="_blank" rel="noopener noreferrer">🔥 开源地址<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><h1 id="第7节-高质量的makefile" tabindex="-1"><a class="header-anchor" href="#第7节-高质量的makefile" aria-hidden="true">#</a> 第7节 高质量的Makefile</h1><br><div><a href="6.md" style="float:left;">⬆️上一节🔗 </a><a href="8.md" style="float:right;"> ⬇️下一节🔗</a></div><br><blockquote><p>❤️💕💕During the winter vacation, I followed up and learned two projects: tiktok project and IAM project, and summarized and practiced the CloudNative project and Go language. I learned a lot in the process.Myblog:<a href="http://nsddd.top/" target="_blank" rel="noopener noreferrer">http://nsddd.top<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><hr><nav class="table-of-contents"><ul><li><a aria-current="page" href="/iam/projects/7.html#低质量的makefile" class="router-link-active router-link-exact-active">低质量的makefile</a></li><li><a aria-current="page" href="/iam/projects/7.html#makefile-如何工作" class="router-link-active router-link-exact-active">makefile 如何工作</a><ul><li><a aria-current="page" href="/iam/projects/7.html#build-and-run" class="router-link-active router-link-exact-active">Build and Run</a></li><li><a aria-current="page" href="/iam/projects/7.html#cleaning-and-drying" class="router-link-active router-link-exact-active">Cleaning and DRYing</a></li><li><a aria-current="page" href="/iam/projects/7.html#phony-targets" class="router-link-active router-link-exact-active">PHONY targets</a></li><li><a aria-current="page" href="/iam/projects/7.html#recursive-make-targets" class="router-link-active router-link-exact-active">Recursive Make targets</a></li><li><a aria-current="page" href="/iam/projects/7.html#targets-for-docker-commands" class="router-link-active router-link-exact-active">Targets for Docker commands</a></li><li><a aria-current="page" href="/iam/projects/7.html#符号" class="router-link-active router-link-exact-active">@ 符号</a></li><li><a aria-current="page" href="/iam/projects/7.html#文件搜索-vpath" class="router-link-active router-link-exact-active">文件搜索 VPATH</a></li><li><a aria-current="page" href="/iam/projects/7.html#help-target" class="router-link-active router-link-exact-active">Help target</a></li><li><a aria-current="page" href="/iam/projects/7.html#conclusion-结论" class="router-link-active router-link-exact-active">Conclusion 结论</a></li></ul></li><li><a aria-current="page" href="/iam/projects/7.html#熟练makefile语法" class="router-link-active router-link-exact-active">熟练makefile语法</a><ul><li><a aria-current="page" href="/iam/projects/7.html#常用的-makefile-核心语法" class="router-link-active router-link-exact-active">常用的 Makefile 核心语法</a></li><li><a aria-current="page" href="/iam/projects/7.html#makefile-支持的通配符" class="router-link-active router-link-exact-active">makefile 支持的通配符</a></li><li><a aria-current="page" href="/iam/projects/7.html#变量" class="router-link-active router-link-exact-active">变量</a></li><li><a aria-current="page" href="/iam/projects/7.html#函数" class="router-link-active router-link-exact-active">函数</a></li><li><a aria-current="page" href="/iam/projects/7.html#引入其他-makefile" class="router-link-active router-link-exact-active">引入其他 Makefile</a></li></ul></li><li><a aria-current="page" href="/iam/projects/7.html#设计makefile结构" class="router-link-active router-link-exact-active">设计Makefile结构</a></li><li><a aria-current="page" href="/iam/projects/7.html#掌握-makefile-编写技巧" class="router-link-active router-link-exact-active">掌握 Makefile 编写技巧</a><ul><li><a aria-current="page" href="/iam/projects/7.html#技巧-1-善用通配符和自动变量" class="router-link-active router-link-exact-active">技巧 1：善用通配符和自动变量</a></li><li><a aria-current="page" href="/iam/projects/7.html#技巧-2-善用函数" class="router-link-active router-link-exact-active">技巧 2：善用函数</a></li><li><a aria-current="page" href="/iam/projects/7.html#技巧-3-依赖需要用到的工具" class="router-link-active router-link-exact-active">技巧 3：依赖需要用到的工具</a></li><li><a aria-current="page" href="/iam/projects/7.html#技巧-4-把常用功能放在-makefile-中-不常用的放在分类-makefile-中" class="router-link-active router-link-exact-active">技巧 4：把常用功能放在 /Makefile 中，不常用的放在分类 Makefile 中</a></li><li><a aria-current="page" href="/iam/projects/7.html#技巧-5-编写可扩展的-makefile" class="router-link-active router-link-exact-active">技巧 5：编写可扩展的 Makefile</a></li><li><a aria-current="page" href="/iam/projects/7.html#技巧-6-将所有输出存放在一个目录下-方便清理和查找" class="router-link-active router-link-exact-active">技巧 6：将所有输出存放在一个目录下，方便清理和查找</a></li><li><a aria-current="page" href="/iam/projects/7.html#技巧-7-使用带层级的命名方式" class="router-link-active router-link-exact-active">技巧 7：使用带层级的命名方式</a></li><li><a aria-current="page" href="/iam/projects/7.html#技巧-8-做好目标拆分" class="router-link-active router-link-exact-active">技巧 8：做好目标拆分</a></li><li><a aria-current="page" href="/iam/projects/7.html#技巧-9-设置-options" class="router-link-active router-link-exact-active">技巧 9：设置 OPTIONS</a></li><li><a aria-current="page" href="/iam/projects/7.html#技巧-10-定义环境变量" class="router-link-active router-link-exact-active">技巧 10：定义环境变量</a></li><li><a aria-current="page" href="/iam/projects/7.html#技巧-11-自己调用自己" class="router-link-active router-link-exact-active">技巧 11：自己调用自己</a></li></ul></li><li><a aria-current="page" href="/iam/projects/7.html#makefile-多线程" class="router-link-active router-link-exact-active">Makefile 多线程</a></li><li><a aria-current="page" href="/iam/projects/7.html#makefile-参数" class="router-link-active router-link-exact-active">Makefile 参数</a><ul><li><a aria-current="page" href="/iam/projects/7.html#常用的参数" class="router-link-active router-link-exact-active">常用的参数</a></li></ul></li><li><a aria-current="page" href="/iam/projects/7.html#补充-makefile-go语言交叉编译" class="router-link-active router-link-exact-active">补充：Makefile Go语言交叉编译</a><ul><li><a aria-current="page" href="/iam/projects/7.html#获取版本号" class="router-link-active router-link-exact-active">获取版本号</a></li><li><a aria-current="page" href="/iam/projects/7.html#实现交叉编译" class="router-link-active router-link-exact-active">实现交叉编译</a></li></ul></li><li><a aria-current="page" href="/iam/projects/7.html#总结" class="router-link-active router-link-exact-active">总结</a></li><li><a aria-current="page" href="/iam/projects/7.html#end-链接" class="router-link-active router-link-exact-active">END 链接</a><ul><li><a aria-current="page" href="/iam/projects/7.html#links" class="router-link-active router-link-exact-active">LInks</a></li></ul></li></ul></nav><p>[TOC]</p><h2 id="低质量的makefile" tabindex="-1"><a class="header-anchor" href="#低质量的makefile" aria-hidden="true">#</a> 低质量的makefile</h2><p>低质量的 Makefile 文件是什么样的;</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token target symbol">build</span><span class="token punctuation">:</span> clean vet
  <span class="token operator">@</span>mkdir -p ./Role
  <span class="token operator">@</span><span class="token keyword">export</span> GOOS<span class="token operator">=</span>linux &amp;&amp; go build -v .

<span class="token target symbol">vet</span><span class="token punctuation">:</span>
  go vet ./...

<span class="token target symbol">fmt</span><span class="token punctuation">:</span>
  go fmt ./...

<span class="token target symbol">clean</span><span class="token punctuation">:</span>
  rm -rf dashboard
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个 Makefile 存在不少问题。例如：功能简单，只能完成最基本的编译、格式化等操作，像构建镜像、自动生成代码等一些高阶的功能都没有；扩展性差，没法编译出可在 Mac 下运行的二进制文件；没有 Help 功能，使用难度高；单 Makefile 文件，结构单一，不适合添加一些复杂的管理功能。</p><p>所以，我们不光要编写 Makefile，还要编写高质量的 Makefile。那么如何编写一个高质量的 Makefile 呢？我觉得，可以通过以下 4 个方法来实现：</p><ul><li>打好基础，也就是熟练掌握 <code>Makefile</code> 的语法。</li><li>做好准备工作，也就是提前规划 <code>Makefile</code> 要实现的功能。</li><li>进行规划，设计一个合理的 <code>Makefile</code> 结构。</li><li>掌握方法，用好 <code>Makefile</code> 的编写技巧。</li></ul><h2 id="makefile-如何工作" tabindex="-1"><a class="header-anchor" href="#makefile-如何工作" aria-hidden="true">#</a> makefile 如何工作</h2><p><img src="http://sm.nsddd.top/sm202302192223604.png" alt="image-20230219222355491"></p><p><strong>makefile规则：</strong></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>target <span class="token punctuation">..</span>. <span class="token builtin class-name">:</span> prerequisites <span class="token punctuation">..</span>.
    <span class="token builtin class-name">command</span>
    <span class="token punctuation">..</span>.
    <span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>target</strong><ul><li>可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。</li></ul></li><li><strong>prereqisites</strong><ul><li>生成该target所依赖的文件和/或target</li></ul></li><li><strong>command</strong><ul><li>该target要执行的命令（任意的shell命令）</li></ul></li></ul><blockquote><p>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。</p></blockquote><h3 id="build-and-run" tabindex="-1"><a class="header-anchor" href="#build-and-run" aria-hidden="true">#</a> Build and Run</h3><p><strong>首先两个特别频繁的指令加进去：</strong></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>build: 
    go build <span class="token parameter variable">-o</span> stringifier main.go

run:
    go run <span class="token parameter variable">-race</span> main.gobuild: 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我在运行命令中添加了<code>-race</code>标志，方便它在运行时在Go代码中检测到<code>race</code>情况。</p><h3 id="cleaning-and-drying" tabindex="-1"><a class="header-anchor" href="#cleaning-and-drying" aria-hidden="true">#</a> Cleaning and DRYing</h3><p>构建二进制文件并运行应用程序后，一切正常, 确保我们在执行其他任何操作之前先清理二进制文件。我们更新<code>Makefile</code>应该看起来像这样：</p><div class="language-go ext-go line-numbers-mode"><pre class="language-go"><code>clean<span class="token punctuation">:</span>
	<span class="token keyword">go</span> clean<span class="token punctuation">:</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>我们有两点可以改进</strong>:</p><ol><li>我们明确地重用了我们的应用程序名, 很自然我们的应用程序名称将在整个<code>Makefile</code>中的许多地方使用。</li><li>每次构建应用之前，我们需要先执行<code>clean</code>的规则。</li></ol><p><strong>改进后的<code>Makefile</code></strong></p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>APP<span class="token operator">=</span>stringifier

<span class="token target symbol">build</span><span class="token punctuation">:</span> clean
	go build -o <span class="token variable">$</span><span class="token punctuation">{</span>APP<span class="token punctuation">}</span> main.go

<span class="token target symbol">run</span><span class="token punctuation">:</span>
	go run -race main.go

<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	go clean
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>更新</strong>: 这个例子之前使用的<code>rm -r ${APP}</code>，现在使用<code>go clean</code>。</p><p>在顶部定义<code>Makefile</code>变量，当您调用<code>make</code>命令时make将自动引用它们，这样<code>Makefile</code>看起来就更整洁、规范了。</p><h3 id="phony-targets" tabindex="-1"><a class="header-anchor" href="#phony-targets" aria-hidden="true">#</a> PHONY targets</h3><p>在 Makefile 中，<code>.PHONY</code> 是一个特殊的目标（target），它用于定义那些不表示实际文件的伪目标（phony target）。</p><p>当 Makefile 执行时，它会检查定义的目标是否已经存在或是否需要更新。对于伪目标，由于它们不表示任何实际文件，因此 Makefile 无法检查它们是否已经存在或是否需要更新。为了避免误判，<strong>可以使用 <code>.PHONY</code> 来明确告诉 Makefile 哪些目标是伪目标，以便在执行时跳过对这些目标的检查。</strong></p><p>例如，假设 Makefile 中定义了一个 clean 目标用于删除生成的文件，但是 clean 并不表示任何实际的文件，只是一个伪目标。那么，为了确保 Makefile 在执行时不会将 clean 当成一个文件来检查，可以在 Makefile 中添加如下声明：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean

<span class="token target symbol">clean</span><span class="token punctuation">:</span>
    rm -f *.o myprogram
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>这样，当执行 &quot;make clean&quot; 命令时，Makefile 会跳过对 clean 目标的文件检查，直接执行清理命令。同时，如果我们在 Makefile 中定义了一个与 clean 相同名字的文件，Makefile 也不会将其与 clean 目标混淆。因此，使用 <code>.PHONY</code> 声明伪目标可以提高 Makefile 的可读性和可靠性。</p></blockquote><p><strong>默认情况下</strong>，如果一个前置条件或是目录文件已更改，<code>make</code>将执行规则。但是由于我们不依赖于<code>make</code>来检测文件更改的能力，因此我们会遇到潜在的麻烦。</p><p>假设我们的项目目录中有一个名为 <code>build</code> 的文件, 在这个场景下，当你执行<code>make build</code>, make一定会检查文件build的更改，由于没有前置条件，因此将始终将<code>build</code>文件视为最新的，并且不会执行其规则定义的操作。</p><p>为了避免这个问题，你需要先知道<code>.PHONY</code> 特殊目录(target)是什么意思：<strong>特殊目标<code>.PHONY</code>的先决条件被视为phony目标（targets)。 当需要运行时，make会无条件运行其规则，而不管该名称的文件是否存在或其最后修改时间是多少。</strong></p><p>所以，你可以通过将目标（target）指定为特殊目标<code>.PHONY</code>的先决条件，将目标指定为<code>.PHONY</code>。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>APP<span class="token operator">=</span>stringifier

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build
<span class="token target symbol">build</span><span class="token punctuation">:</span> clean
	go build -o <span class="token variable">$</span><span class="token punctuation">{</span>APP<span class="token punctuation">}</span> main.go

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> run
<span class="token target symbol">run</span><span class="token punctuation">:</span>
	go run -race main.go

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	go clean
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在你已将上述所有的<code>targets</code>指定为<code>phony</code>, 每次你调用任何<code>phony</code>目标（target) 时，make将会执行相应的规则。你还可以一次将所有要指定为<code>phony</code>的目标指定为:</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build clean run
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是对于非常大的Makefile，不建议这样做因为这可能导致歧义和无法读取。因此，首选方法是在规则定义之前显式设置<code>phony</code>目标（target）。</p><h3 id="recursive-make-targets" tabindex="-1"><a class="header-anchor" href="#recursive-make-targets" aria-hidden="true">#</a> Recursive Make targets</h3><p>当 Makefile 包含多个目标时，我们可以在 Makefile 中使用递归 Make 来构建这些目标。递归 Make 指的是在 Makefile 中调用另一个 Makefile 来构建其中的目标。</p><p>在递归 Make 中，通常有一个顶层 Makefile，该 Makefile 调用其他 Makefile 来构建子目录中的目标。这样的 Makefile 被称为 &quot;递归 Makefile&quot;，而由这个 Makefile 调用的 Makefile 被称为 &quot;子 Makefile&quot;。</p><p><strong>在递归 Make 中，每个子 Makefile 负责构建它所在的目录中的目标，然后将构建的结果返回给父 Makefile。递归 Make 的一个常见的问题是，当在子目录中调用 Make 命令时，可能会破坏父目录中的变量设置和规则，因此需要小心地设置变量和规则，以避免不必要的冲突。</strong></p><p>递归 Make 的一种常见用法是使用一个称为“递归变量”的特殊变量。递归变量的值可以包含调用另一个 Makefile 的命令，这个命令会返回一个值，可以被递归变量使用。递归变量在递归 Make 中非常有用，因为它们可以帮助子 Makefile 获得父 Makefile 中的变量值。</p><p>例如，我们可以在项目的根目录下创建一个名为 &quot;Makefile&quot; 的文件，其内容如下：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>SUBDIRS <span class="token operator">=</span> foo bar baz

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> all <span class="token variable">$</span><span class="token punctuation">(</span>SUBDIRS<span class="token punctuation">)</span>

<span class="token target symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>SUBDIRS<span class="token punctuation">)</span>

<span class="token target symbol"><span class="token variable">$</span>(SUBDIRS)</span><span class="token punctuation">:</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C <span class="token variable">$@</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的 Makefile 中，&quot;SUBDIRS&quot; 变量定义了项目的子目录名称。&quot;all&quot; 是一个伪目标，它将调用每个子目录中的 Makefile 来构建所有目标。</p><p><code>$(SUBDIRS)</code> 是一个自动变量，它会展开为 &quot;foo bar baz&quot;。因此，当我们运行 &quot;make all&quot; 命令时，它将首先调用 &quot;make foo&quot;，然后在 &quot;foo&quot; 目录中运行 &quot;make&quot; 命令来构建 &quot;foo&quot; 目录中的目标。接着它会依次调用 &quot;make bar&quot; 和 &quot;make baz&quot; 命令，以此类推。</p><p>在子目录的 Makefile 中，我们可以使用和普通 Makefile 中一样的规则和变量定义来构建子目录中的目标。这种方式可以帮助我们轻松地管理复杂的项目，避免代码重复，并提高 Makefile 的可重用性。</p><p>现在让我们假设我们在项目中使用的根目录中还有另一个模块<code>tokenizer</code>。现在我们的目录结构是这样的：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>~/programming/stringifier
<span class="token builtin class-name">.</span>
├── main.go
├── Makefile
└── tokenizer/
      ├── main.go
      └── Makefile~/programming/stringifier
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很自然，某些时候我们也想<code>build</code>和<code>test</code>我们的<code>tokenizer</code>模块。由于它是一个独立的模块也可能是一个独立的项目，在它的目录有如下内容的一个<code>Makefile</code>是很有必要的：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token comment"># ~/programming/stringifier/tokenizer/Makefile</span>

APP<span class="token operator">=</span>tokenizer

<span class="token target symbol">build</span><span class="token punctuation">:</span>
	go build -o <span class="token variable">$</span><span class="token punctuation">{</span>APP<span class="token punctuation">}</span> main.go
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在只要您在<code>stringifier</code>项目的根目录中并且想要构建<code>tokenizer</code>应用程序，你不会想使用诸如<code>cd tokenizer &amp;&amp; make build &amp;&amp; cd - </code>这样的易受攻击的命令行技巧，而具体的<code>Makefiles</code>的规则写在子目录中的方式。幸运的是，<code>make</code>可以帮助你解决这个问题。你可以使用<code>-C</code>标志和特殊的<code>${NAME}</code>变量在其他目录中调用<code>make targets</code>。下面是<code>stringifies</code>项目最初的Makefile:</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token comment"># ~/programming/stringifier/Makefile</span>

APP<span class="token operator">=</span>stringifier

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build
<span class="token target symbol">build</span><span class="token punctuation">:</span> clean
	go build -o <span class="token variable">$</span><span class="token punctuation">{</span>APP<span class="token punctuation">}</span> main.go

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> run
<span class="token target symbol">run</span><span class="token punctuation">:</span>
	go run -race main.go

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	go clean

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build-tokenizer
<span class="token target symbol">build-tokenizer</span><span class="token punctuation">:</span>
	<span class="token variable">$</span><span class="token punctuation">{</span>MAKE<span class="token punctuation">}</span> -C tokenizer build
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在只要你运行<code>make build-tokenizer</code>，<code>make</code>都将为您处理目录切换，并以更加可读和健壮的方式为您调用正确目录中的正确目标</p><p><strong><code>-c</code> 标志和特殊的 <code>${NAME}</code>:</strong></p><ol><li><p><code>-C</code> 标志：指定 Makefile 文件的目录，让 make 命令在指定的目录下执行 Makefile 文件。例如：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token target symbol">all</span><span class="token punctuation">:</span>
     cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上述 Makefile 中的 <code>$(MAKE)</code> 命令会在当前目录下的 <code>subdir</code> 目录中执行 Makefile 文件。可以使用 <code>-C</code> 标志来达到同样的效果：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token target symbol">all</span><span class="token punctuation">:</span>
     <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C subdir
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>${NAME}</code> 变量：在 Makefile 中使用 <code>${NAME}</code> 变量可以引用环境变量中的值，例如：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token target symbol">all</span><span class="token punctuation">:</span>
     echo <span class="token string">&quot;PATH is ${PATH}&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上述 Makefile 中的 <code>${PATH}</code> 变量会展开为当前系统环境变量中的 <code>PATH</code> 值。</p></li></ol><p>以下是一个用 Go 语言编写的 Makefile 示例，其中使用了 <code>-C</code> 标志和 <code>${NAME}</code> 变量：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token comment"># Makefile</span>

APP_NAME <span class="token operator">:=</span> my-app

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build
<span class="token target symbol">build</span><span class="token punctuation">:</span>
    cd cmd/my-app &amp;&amp; go build -o ../../bin/<span class="token variable">$</span><span class="token punctuation">(</span>APP_NAME<span class="token punctuation">)</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> test
<span class="token target symbol">test</span><span class="token punctuation">:</span>
    go test ./...

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
    rm -rf bin/*

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build-docker
<span class="token target symbol">build-docker</span><span class="token punctuation">:</span> build
    docker build -t <span class="token variable">$</span><span class="token punctuation">(</span>APP_NAME<span class="token punctuation">)</span> .

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> run-docker
<span class="token target symbol">run-docker</span><span class="token punctuation">:</span> build-docker
<span class="token target symbol">    docker run -p 8080</span><span class="token punctuation">:</span>8080 <span class="token variable">$</span><span class="token punctuation">(</span>APP_NAME<span class="token punctuation">)</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> deploy
<span class="token target symbol">deploy</span><span class="token punctuation">:</span> build-docker
    ssh <span class="token variable">$</span><span class="token punctuation">{</span>SSH_USER<span class="token punctuation">}</span><span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">{</span>SSH_HOST<span class="token punctuation">}</span> <span class="token string">&quot;docker pull $(APP_NAME); docker stop $(APP_NAME) || true; docker rm $(APP_NAME) || true; docker run -p 8080:8080 -d --name $(APP_NAME) $(APP_NAME)&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述 Makefile 中，<code>build-docker</code>、<code>run-docker</code> 和 <code>deploy</code> 等目标中使用了 <code>${APP_NAME}</code> 变量来指定 Docker 镜像的名称，同时使用了 <code>-C</code> 标志来在子目录中执行命令，例如 <code>build</code> 目标中的 <code>cd cmd/my-app &amp;&amp; go build</code> 命令。</p><h3 id="targets-for-docker-commands" tabindex="-1"><a class="header-anchor" href="#targets-for-docker-commands" aria-hidden="true">#</a> Targets for Docker commands</h3><p>现在您希望对应用程序进行容器化，然后为方便起见编写make目标，这是完全可以理解的。</p><p>你为docker命令定义了如下规则：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> docker-build
<span class="token target symbol">docker-build</span><span class="token punctuation">:</span> build
	docker build -t stringifier .
<span class="token target symbol">	docker tag stringifier stringifier</span><span class="token punctuation">:</span>tag

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> docker-push
<span class="token target symbol">docker-push</span><span class="token punctuation">:</span> docker-build
<span class="token target symbol">	docker push gcr.io/stringifier/stringifier-staging/stringifier</span><span class="token punctuation">:</span>tag
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>docker命令基本满足需要，但是还有改善的空间，</p><ul><li>对于新手，你可以再次重用你的<code>${APP}</code>变量。</li><li>接下来，您想要更灵活并确保可以轻松控制将映像推送到哪里，无论是您的私人镜像仓库还是其他地方。</li><li>然后，您希望能够根据用户在命令行上的某些输入将镜像（image）分别推送到与预生产和生产环境有关的两个单独的镜像仓库中。</li><li>最后，像一个理智的开发人员一样，您想使用当前的 <code>git commit sha</code> 标记您的镜像（image）。 让我们基于这些问题重新修改下<code>Makefile</code>：</li></ul><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>APP<span class="token operator">?=</span>application
REGISTRY<span class="token operator">?=</span>gcr.io/images
COMMIT_SHA<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> git rev-parse --short HEAD<span class="token punctuation">)</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> docker-build
<span class="token target symbol">docker-build</span><span class="token punctuation">:</span> build
	docker build -t <span class="token variable">$</span><span class="token punctuation">{</span>APP<span class="token punctuation">}</span> .
<span class="token target symbol">	docker tag <span class="token variable">$</span>{APP} <span class="token variable">$</span>{APP}</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">{</span>COMMIT_SHA<span class="token punctuation">}</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> docker-push
<span class="token target symbol">docker-push</span><span class="token punctuation">:</span> check-environment docker-build
<span class="token target symbol">	docker push <span class="token variable">$</span>{REGISTRY}/<span class="token variable">$</span>{ENV}/<span class="token variable">$</span>{APP}</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">{</span>COMMIT_SHA<span class="token punctuation">}</span>

<span class="token target symbol">check-environment</span><span class="token punctuation">:</span>
<span class="token keyword">ifndef</span> ENV
    <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">error</span> ENV not set, allowed values - `staging` or `production`<span class="token punctuation">)</span>
<span class="token keyword">endif</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，让我们回顾下上面的更改：</p><ul><li>你开始为应用程序名称，镜像名称，提交sha使用变量。</li><li>您使用特殊的shell函数生成了commit sha。 在这种情况下，您运行了git命令，该命令返回了简短的提交sha，并将其分配给变量<code>${COMMIT_SHA}</code>，以便稍后在Makefile中使用。</li><li>您添加了一个新的规则<code>check-environment</code>，该环境使用make条件检查在调用make时是否指定了<code>ENV</code>变量，这有助于区分预生产及生产环境。</li></ul><p><code>check-environment</code>的规则如下：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token target symbol">check-environment</span><span class="token punctuation">:</span>
<span class="token keyword">ifndef</span> ENV
    <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">error</span> ENV not set, allowed values - `staging` or `production`<span class="token punctuation">)</span>
<span class="token keyword">endif</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>ifndef</code>指令检查变量ENV是否为空值，如果存在，则使用另一个make的提供内置函数，如果出错了，将会在关键字之后抛出具体的错误消息。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">make</span> docker-push
Makefile:33: *** ENV not set, allowed values - <span class="token variable"><span class="token variable">`</span>staging<span class="token variable">`</span></span> or <span class="token variable"><span class="token variable">`</span>production<span class="token variable">`</span></span><span class="token builtin class-name">.</span>  Stop.

$ <span class="token assign-left variable">ENV</span><span class="token operator">=</span>staging <span class="token function">make</span> docker-push
Success
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>本质上，您要确保docker-push目标具有安全保障，该保障可检查调用目标的用户是否已为ENV变量指定值。</p><h3 id="符号" tabindex="-1"><a class="header-anchor" href="#符号" aria-hidden="true">#</a> <code>@</code> 符号</h3><p>项目的 <code>makefile</code> 中很容易看到 <code>@</code> 符号的存在，它的意义不同寻常：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token comment">## build: Build source code for host platform.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build
<span class="token target symbol">build</span><span class="token punctuation">:</span>
	<span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> go.build
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在Makefile中，<code>@</code>符号用于 <strong>抑制Make命令的输出</strong>。当在Makefile中使用<code>@</code>符号时，<strong>Make将不会打印出该行命令的输出结果，而是仅仅执行该命令。</strong></p><p>在Go语言项目中，我们通常使用Makefile来构建和管理项目。下面是一个简单的Go语言项目Makefile示例：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token comment"># 编译二进制文件</span>
<span class="token target symbol">build</span><span class="token punctuation">:</span>
    <span class="token operator">@</span>go build -o myapp main.go

<span class="token comment"># 运行程序</span>
<span class="token target symbol">run</span><span class="token punctuation">:</span>
    <span class="token operator">@</span>./myapp

<span class="token comment"># 清理</span>
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
    <span class="token operator">@</span>rm -f myapp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，我们定义了三个Makefile命令：<code>build</code>，<code>run</code>和<code>clean</code>。在每个命令的前面，我们都使用了<code>@</code>符号来抑制命令的输出。这意味着，当我们在命令行中运行<code>make build</code>时，Make命令将会编译Go程序，但不会将编译器的输出打印到终端。</p><p>如果我们去掉<code>@</code>符号，那么当我们运行<code>make build</code>时，Make将会输出编译器的输出，类似于下面的结果：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>go build <span class="token parameter variable">-o</span> myapp main.go
<span class="token comment"># 输出编译器的输出</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，使用<code>@</code>符号可以使Makefile输出更加干净，仅仅打印出我们关心的内容，而不会输出一堆不必要的信息。</p><h3 id="文件搜索-vpath" tabindex="-1"><a class="header-anchor" href="#文件搜索-vpath" aria-hidden="true">#</a> 文件搜索 VPATH</h3><p>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。</p><p>Makefile文件中的特殊变量 <code>VPATH</code> 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>VPATH <span class="token operator">=</span> src:<span class="token punctuation">..</span>/headers
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的定义指定两个目录，“src”和“<code>../headers</code>”，<code>make</code>会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）</p><p>另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>vpath &lt;pattern&gt; &lt;directories&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为符合模式<code>&lt;pattern&gt;</code>的文件指定搜索目录<code>&lt;directories&gt;</code>。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>vpath &lt;pattern&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>清除符合模式<code>&lt;pattern&gt;</code>的文件的搜索目录。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>vpath
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>清除所有已被设置好了的文件搜索目录。</p><h3 id="help-target" tabindex="-1"><a class="header-anchor" href="#help-target" aria-hidden="true">#</a> Help target</h3><p>一个新成员加入了该项目并想知道Makefile中所有规则的作用，为帮助它们您可以添加一个新目标(target)，该目标将打印所有目标名称以及它们作用的简短描述:</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build
<span class="token comment">## build: build the application</span>
<span class="token target symbol">build</span><span class="token punctuation">:</span> clean
    <span class="token operator">@</span>echo <span class="token string">&quot;Building...&quot;</span>
    <span class="token operator">@</span>go build -o <span class="token variable">$</span><span class="token punctuation">{</span>APP<span class="token punctuation">}</span> main.go

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> run
<span class="token comment">## run: runs go run main.go</span>
<span class="token target symbol">run</span><span class="token punctuation">:</span>
	go run -race main.go

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean
<span class="token comment">## clean: cleans the binary</span>
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
    <span class="token operator">@</span>echo <span class="token string">&quot;Cleaning&quot;</span>
    <span class="token operator">@</span>go clean

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> setup
<span class="token comment">## setup: setup go modules</span>
<span class="token target symbol">setup</span><span class="token punctuation">:</span>
	<span class="token operator">@</span>go mod init \
		&amp;&amp; go mod tidy \
		&amp;&amp; go mod vendor
	
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> help
<span class="token comment">## help: prints this help message</span>
<span class="token target symbol">help</span><span class="token punctuation">:</span>
	<span class="token operator">@</span>echo <span class="token string">&quot;Usage: \n&quot;</span>
	<span class="token operator">@</span>sed -n <span class="token string">&#39;s/^##//p&#39;</span> <span class="token variable">$</span><span class="token punctuation">{</span>MAKEFILE_LIST<span class="token punctuation">}</span> <span class="token operator">|</span> column -t -s <span class="token string">&#39;:&#39;</span> <span class="token operator">|</span>  sed -e <span class="token string">&#39;s/^/ /&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你先注意下最后一条规则，<code>help</code> 在这里，您只是使用一些sed魔术来解析和在命令行上打印。 但是要做到这一点，您必要在每条规则之前写了目标名称和简短描述作为注释。 注意另一个特殊变量<code>$ {MAKEFILE_LIST}</code>，它是您所引用的所有Makefile的列表，在本例中仅是Makefile。</p><p>您会将文件Makefile作为输入传递给sed命令，该命令将解析所有帮助注释并以表格格式将其打印到stdout，以便于阅读。 上一个代码段的<code>help</code>目标的输出如下所示：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">make</span> <span class="token builtin class-name">help</span>
Usage:
	build             Build the application
	clean             cleans the binary
	run               runs go run main.go
	docker-build      builds <span class="token function">docker</span> image
	docker-push       pushes the <span class="token function">docker</span> image
	setup             <span class="token builtin class-name">set</span> up modules
	<span class="token builtin class-name">help</span>              prints this <span class="token builtin class-name">help</span> message
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些消息很有帮助，对于其他人甚至有时对自己都是一个不错的提示。</p><h3 id="conclusion-结论" tabindex="-1"><a class="header-anchor" href="#conclusion-结论" aria-hidden="true">#</a> Conclusion 结论</h3><p>Make是一个简单但可高度配置的工具。 在本文中，您遍历了make提供的许多配置和功能，从而为Go应用程序编写了有效而高效的Makefile。</p><p>下面是完整的Makefile，其中添加了一些琐碎的规则和变量：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>GO111MODULES<span class="token operator">=</span>on
APP<span class="token operator">?=</span>stringifier
REGISTRY<span class="token operator">?=</span>gcr.io/images
COMMIT_SHA<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> git rev-parse --short HEAD<span class="token punctuation">)</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build
<span class="token comment">## build: build the application</span>
<span class="token target symbol">build</span><span class="token punctuation">:</span> clean
    <span class="token operator">@</span>echo <span class="token string">&quot;Building...&quot;</span>
    <span class="token operator">@</span>go build -o <span class="token variable">$</span><span class="token punctuation">{</span>APP<span class="token punctuation">}</span> main.go

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> run
<span class="token comment">## run: runs go run main.go</span>
<span class="token target symbol">run</span><span class="token punctuation">:</span>
	go run -race main.go

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean
<span class="token comment">## clean: cleans the binary</span>
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
    <span class="token operator">@</span>echo <span class="token string">&quot;Cleaning&quot;</span>
    <span class="token operator">@</span>go clean

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> test
<span class="token comment">## test: runs go test with default values</span>
<span class="token target symbol">test</span><span class="token punctuation">:</span>
	go test -v -count<span class="token operator">=</span>1 -race ./...


<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build-tokenizer
<span class="token comment">## build-tokenizer: build the tokenizer application</span>
<span class="token target symbol">build-tokenizer</span><span class="token punctuation">:</span>
	<span class="token variable">$</span><span class="token punctuation">{</span>MAKE<span class="token punctuation">}</span> -c tokenizer build

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> setup
<span class="token comment">## setup: setup go modules</span>
<span class="token target symbol">setup</span><span class="token punctuation">:</span>
	<span class="token operator">@</span>go mod init \
		&amp;&amp; go mod tidy \
		&amp;&amp; go mod vendor
	
<span class="token comment"># helper rule for deployment</span>
<span class="token target symbol">check-environment</span><span class="token punctuation">:</span>
<span class="token keyword">ifndef</span> ENV
    <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">error</span> ENV not set, allowed values - `staging` or `production`<span class="token punctuation">)</span>
<span class="token keyword">endif</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> docker-build
<span class="token comment">## docker-build: builds the stringifier docker image to registry</span>
<span class="token target symbol">docker-build</span><span class="token punctuation">:</span> build
<span class="token target symbol">	docker build -t <span class="token variable">$</span>{APP}</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">{</span>COMMIT_SHA<span class="token punctuation">}</span> .

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> docker-push
<span class="token comment">## docker-push: pushes the stringifier docker image to registry</span>
<span class="token target symbol">docker-push</span><span class="token punctuation">:</span> check-environment docker-build
<span class="token target symbol">	docker push <span class="token variable">$</span>{REGISTRY}/<span class="token variable">$</span>{ENV}/<span class="token variable">$</span>{APP}</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">{</span>COMMIT_SHA<span class="token punctuation">}</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> help
<span class="token comment">## help: Prints this help message</span>
<span class="token target symbol">help</span><span class="token punctuation">:</span>
	<span class="token operator">@</span>echo <span class="token string">&quot;Usage: \n&quot;</span>
	<span class="token operator">@</span>sed -n <span class="token string">&#39;s/^##//p&#39;</span> <span class="token variable">$</span><span class="token punctuation">{</span>MAKEFILE_LIST<span class="token punctuation">}</span> <span class="token operator">|</span> column -t -s <span class="token string">&#39;:&#39;</span> <span class="token operator">|</span>  sed -e <span class="token string">&#39;s/^/ /&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="熟练makefile语法" tabindex="-1"><a class="header-anchor" href="#熟练makefile语法" aria-hidden="true">#</a> 熟练makefile语法</h2><p><strong>IAM 项目的 Makefile 文件：</strong></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ <span class="token function">make</span> <span class="token builtin class-name">help</span>

Usage: <span class="token function">make</span> <span class="token operator">&lt;</span>TARGETS<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>OPTIONS<span class="token operator">&gt;</span> <span class="token punctuation">..</span>.

Targets:
  <span class="token comment"># 代码生成类命令</span>
  gen                Generate all necessary files, such as error code files.

  <span class="token comment"># 格式化类命令</span>
  <span class="token function">format</span>             Gofmt <span class="token punctuation">(</span>reformat<span class="token punctuation">)</span> package sources <span class="token punctuation">(</span>exclude vendor <span class="token function">dir</span> <span class="token keyword">if</span> existed<span class="token punctuation">)</span>.

  <span class="token comment"># 静态代码检查</span>
  lint               Check syntax and styling of go sources.

  <span class="token comment"># 测试类命令</span>
  <span class="token builtin class-name">test</span>               Run unit test.
  cover              Run unit <span class="token builtin class-name">test</span> and get <span class="token builtin class-name">test</span> coverage.

  <span class="token comment"># 构建类命令</span>
  build              Build <span class="token builtin class-name">source</span> code <span class="token keyword">for</span> <span class="token function">host</span> platform.
  build.multiarch    Build <span class="token builtin class-name">source</span> code <span class="token keyword">for</span> multiple platforms. See option PLATFORMS.

  <span class="token comment"># Docker镜像打包类命令</span>
  image              Build <span class="token function">docker</span> images <span class="token keyword">for</span> <span class="token function">host</span> arch.
  image.multiarch    Build <span class="token function">docker</span> images <span class="token keyword">for</span> multiple platforms. See option PLATFORMS.
  push               Build <span class="token function">docker</span> images <span class="token keyword">for</span> <span class="token function">host</span> arch and push images to registry.
  push.multiarch     Build <span class="token function">docker</span> images <span class="token keyword">for</span> multiple platforms and push images to registry.

  <span class="token comment"># 部署类命令</span>
  deploy             Deploy updated components to development env.

  <span class="token comment"># 清理类命令</span>
  clean              Remove all files that are created by building.

  <span class="token comment"># 其他命令，不同项目会有区别</span>
  release            Release iam
  verify-copyright   Verify the boilerplate headers <span class="token keyword">for</span> all files.
  ca                 Generate CA files <span class="token keyword">for</span> all iam components.
  <span class="token function">install</span>            Install iam system with all its components.
  swagger            Generate swagger document.
  tools              <span class="token function">install</span> dependent tools.

  <span class="token comment"># 帮助命令</span>
  <span class="token builtin class-name">help</span>               Show this <span class="token builtin class-name">help</span> info.

<span class="token comment"># 选项</span>
Options:
  DEBUG        Whether to generate debug symbols. Default is <span class="token number">0</span>.
  BINS         The binaries to build. Default is all of cmd.
               This option is available when using: <span class="token function">make</span> build/build.multiarch
               Example: <span class="token function">make</span> build <span class="token assign-left variable">BINS</span><span class="token operator">=</span><span class="token string">&quot;iam-apiserver iam-authz-server&quot;</span>
  <span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常而言，Go 项目的 Makefile 应该实现以下功能：格式化代码、静态代码检查、单元测试、代码构建、文件清理、帮助等等。如果通过 docker 部署，还需要有 docker 镜像打包功能。因为 Go 是跨平台的语言，所以构建和 docker 打包命令，还要能够支持不同的 CPU 架构和平台。为了能够更好地控制 Makefile 命令的行为，还需要支持 Options。</p><p><strong>为了方便查看 Makefile 集成了哪些功能，我们需要支持 help 命令。help 命令最好通过解析 Makefile 文件来输出集成的功能，例如：</strong></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">## help: Show this help info.</span>
.PHONY: <span class="token builtin class-name">help</span>
help: Makefile
  @echo <span class="token parameter variable">-e</span> <span class="token string">&quot;<span class="token entity" title="\n">\n</span>Usage: make &lt;TARGETS&gt; &lt;OPTIONS&gt; ...<span class="token entity" title="\n">\n</span><span class="token entity" title="\n">\n</span>Targets:&quot;</span>
  @sed <span class="token parameter variable">-n</span> <span class="token string">&#39;s/^##//p&#39;</span> $<span class="token operator">&lt;</span> <span class="token operator">|</span> <span class="token function">column</span> <span class="token parameter variable">-t</span> <span class="token parameter variable">-s</span> <span class="token string">&#39;:&#39;</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token parameter variable">-e</span> <span class="token string">&#39;s/^/ /&#39;</span>
  @echo <span class="token string">&quot;<span class="token variable">$$</span>USAGE_OPTIONS&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 help 命令，通过解析 Makefile 文件中的 <code>##</code> 注释，获取支持的命令。通过这种方式，我们以后新加命令时，就不用再对 help 命令进行修改了。</p><h3 id="常用的-makefile-核心语法" tabindex="-1"><a class="header-anchor" href="#常用的-makefile-核心语法" aria-hidden="true">#</a> 常用的 Makefile 核心语法</h3><p>大多数的 make 都支持“makefile”和“Makefile”这两种文件名，但我建议使用“Makefile”。因为这个文件名第一个字符大写，会很明显，容易辨别。make 也支持 <code>-f</code> 和 <code>--file</code> 参数来指定其他文件名，比如 <code>make -f golang.mk</code> 或者 <code>make --file golang.mk</code> 。</p><h3 id="makefile-支持的通配符" tabindex="-1"><a class="header-anchor" href="#makefile-支持的通配符" aria-hidden="true">#</a> makefile 支持的通配符</h3><p>Makefile 支持三种类型的通配符，他们是：<code>*，? 和~</code></p><ol><li><strong><code>*</code>通配符：</strong></li></ol><p>*通配符代表任意长度的字符序列，可以匹配任意长度的文件名或路径名中的任意字符。例如，可以使用以下规则来匹配所有.c文件：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>SRCS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> *.c<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这条规则将会将当前目录下所有以<code>.c</code>为后缀的文件名赋值给变量SRCS，使得我们可以方便地引用这些文件。</p><ol start="2"><li><strong><code>?</code>通配符：</strong></li></ol><p>?通配符代表任意单个字符，可以匹配任意长度的文件名或路径名中的一个字符。例如，可以使用以下规则来匹配所有三个字符长的<code>.txt</code>文件：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>SRCS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> ???.txt<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这条规则将会将当前目录下所有文件名长度为3，并以.txt为后缀的文件名赋值给变量SRCS。</p><ol start="3"><li><strong><code>~</code>通配符：</strong></li></ol><p>~通配符代表当前用户的<code>home</code>目录，可以用来指定文件路径。例如，可以使用以下规则来指定当前用户的<code>home</code>目录：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token variable"><span class="token variable">$(</span><span class="token environment constant">HOME</span><span class="token variable">)</span></span>~/myprogram
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这条规则将会将当前用户的home目录路径和myprogram字符串拼接起来，从而得到一个完整的路径名，使得我们可以方便地引用home目录下的文件或路径。</p><h3 id="变量" tabindex="-1"><a class="header-anchor" href="#变量" aria-hidden="true">#</a> 变量</h3><p>变量，可能是 Makefile 中使用最频繁的语法了，Makefile 支持变量赋值、多行变量和环境变量。另外，Makefile 还内置了一些特殊变量和自动化变量。</p><p><strong>变量赋值 ：</strong></p><p>Makefile 也可以像其他语言一样支持变量。在使用变量时，会像 shell 变量一样原地展开，然后再执行替换后的内容。</p><p>Makefile 可以通过变量声明来声明一个变量，变量在声明时需要赋予一个初值，比如<code>ROOT_PACKAGE=github.com/marmotedu/iam</code>。</p><p>引用变量时可以通过<code>$()</code>或者<code>${}</code>方式引用。我的建议是，用<code>$()</code>方式引用变量，例如<code>$(ROOT_PACKAGE)</code>，也建议整个 makefile 的变量引用方式保持一致。</p><p>变量会像 bash 变量一样，在使用它的地方展开。比如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token assign-left variable">GO</span><span class="token operator">=</span>go
build:
    <span class="token variable"><span class="token variable">$(</span>GO<span class="token variable">)</span></span> build <span class="token parameter variable">-v</span> <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>展开后为：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token assign-left variable">GO</span><span class="token operator">=</span>go
build:
    go build <span class="token parameter variable">-v</span> <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Makefile 有四种的赋值方式：</strong></p><p><strong><code>=</code> 最基本的赋值方法。</strong></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>BASE_IMAGE <span class="token operator">=</span> alpine:3.10
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>💡 注意：<strong>使用 <code>=</code> 赋值的时候，取值到的并非是程序依次执行的值，而是最终的值</strong></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>A <span class="token operator">=</span> a
B <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>A<span class="token variable">)</span></span> b
A <span class="token operator">=</span> c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>B 最后的值为 c b，而不是 a b。也就是说，在用变量给变量赋值时，右边变量的取值，取的是最终的变量值。</p></blockquote><p><strong>和go一样，<code>:=</code>直接赋值，赋予当前位置的值。</strong></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>A <span class="token operator">=</span> a
B :<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>A<span class="token variable">)</span></span> b
A <span class="token operator">=</span> c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>B 最后的值为 a b。通过 <code>:=</code> 的赋值方式，可以避免 <code>=</code> 赋值带来的潜在的不一致。</p><p><strong><code>?=</code> 表示如果该变量没有被赋值，则赋予等号后的值。</strong></p><p><strong>例如：</strong></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>PLATFORMS ?<span class="token operator">=</span> linux_amd64 linux_arm64
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong><code>+=</code>表示将等号后面的值添加到前面的变量上。</strong></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>MAKEFLAGS += --no-print-directory
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Makefile 还支持多行变量。可以通过 define 关键字设置多行变量，变量中允许换行。定义方式为：</strong></p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">define</span> 变量名
变量内容
...
<span class="token keyword">endef</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>变量的内容可以包含函数、命令、文字或是其他变量。例如，我们可以定义一个 <code>USAGE_OPTIONS</code> 变量：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">define</span> USAGE_OPTIONS

<span class="token target symbol">Options</span><span class="token punctuation">:</span>
  DEBUG        Whether to generate debug symbols. Default is 0.
  BINS         The binaries to build. Default is all of cmd.
  ...
  V            Set to 1 enable verbose build. Default is 0.
<span class="token keyword">endef</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Makefile 还支持环境变量。在 Makefile 中，有两种环境变量，分别是 Makefile 预定义的环境变量和自定义的环境变量。</p><p>其中，自定义的环境变量可以覆盖 Makefile 预定义的环境变量。默认情况下，Makefile 中定义的环境变量只在当前 Makefile 有效，如果想向下层传递（Makefile 中调用另一个 Makefile），需要使用 export 关键字来声明。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>...
<span class="token keyword">export</span> USAGE_OPTIONS
...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，Makefile 还支持两种内置的变量：特殊变量和自动化变量。</p><p>特殊变量是 make 提前定义好的，可以在 makefile 中直接引用。特殊变量列表如下：</p><p><img src="http://sm.nsddd.top/sm202302201636940.png" alt="image-20230220163605753"></p><p>Makefile 还支持自动化变量。自动化变量可以提高我们编写 Makefile 的效率和质量。</p><p><strong>自动化变量：</strong></p><p>自动化变量也叫做系统变量，这个是非常有用的，一个好的 Makefile 工作者不亚于 bash 的脚本小子，自动化变量占比非常高：</p><table><thead><tr><th>变量</th><th>用途</th></tr></thead><tbody><tr><td><code>$@</code></td><td>表示规则的目标文件名</td></tr><tr><td><code>$%</code></td><td>当目标文件是一个静态库文件时，代表静态库的一个成员名</td></tr><tr><td><code>$&lt;</code></td><td>规则的第一个依赖的文件名</td></tr><tr><td><code>$?</code></td><td>所有目标文件更新的依赖文件列表，空格分隔</td></tr><tr><td><code>$^</code></td><td>代表的是所有依赖文件列表，使用空格分隔</td></tr><tr><td><code>$+</code></td><td>类似<code>$^</code>，但是它保留了依赖文件中重复出现的文件。主要用在程序链接时库的交叉引用场合。</td></tr><tr><td><code>$*</code></td><td>在模式规则和静态模式规则中，代表“茎”。“茎”是目标模式中“%”所代表的部分（当文件名中存在目录时， “茎”也包含目录部分）。</td></tr><tr><td><code>$(@D)</code></td><td>表示文件的目录部分（不包括斜杠）。如果 <code>$@</code> 表示的是 <code>dir/foo.o</code> 那么 <code>$(@D)</code> 表示的值就是 <code>dir</code>。如果 <code>$@</code> 不存在斜杠（文件在当前目录下），其值就是 <code>.</code></td></tr><tr><td><code>$(@F)</code></td><td>表示的是文件除目录外的部分（实际的文件名）。如果 <code>$@</code> 表示的是 <code>dir/foo.o</code>，那么 <code>$@F</code> 表示的值为 <code>foo.o</code></td></tr></tbody></table><p>💡简单的一个案例如下：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>test:test.o test1.o test2.o
         gcc <span class="token parameter variable">-o</span> <span class="token variable">$@</span> $^ <span class="token comment">#等同于gcc -o test test.o test1.o test2.o</span>
test.o:test.c test.h
         gcc <span class="token parameter variable">-o</span> <span class="token variable">$@</span> $<span class="token operator">&lt;</span>
test1.o:test1.c test1.h
         gcc <span class="token parameter variable">-o</span> <span class="token variable">$@</span> $<span class="token operator">&lt;</span>
test2.o:test2.c test2.h
         gcc <span class="token parameter variable">-o</span> <span class="token variable">$@</span> $<span class="token operator">&lt;</span>  <span class="token comment">#等同于gcc -o test2.o test2.c</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时就可以用到自动化变量。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，一直到所有符合模式的文件都取完为止。这种自动化变量只应出现在规则的命令中。Makefile 中支持的自动化变量见下表。</p><p><img src="http://sm.nsddd.top/sm202303181839805.png" alt="image-20230220163723550"></p><p>上面这些自动化变量中，<code>$*</code>是用得最多的。<code>$*</code> 对于构造有关联的文件名是比较有效的。如果目标中没有模式的定义，那么 <code>$*</code> 也就不能被推导出。但是，如果目标文件的后缀是 make 所识别的，那么 <code>$*</code> 就是除了后缀的那一部分。例如：如果目标是 <code>foo.c</code> ，因为.c 是 make 所能识别的后缀名，所以 <code>$*</code> 的值就是 foo。</p><blockquote><p><code>$*</code> 是一个自动变量，表示目标的名称，即这个规则被应用于哪个目标。例如，如果在命令行上输入 <code>make tools.install.foo</code>，那么 <code>$*</code> 的值将是 <code>foo</code>。在 Makefile 规则中，可以使用 <code>$*</code> 来引用目标名称，例如：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>build.%:
    go build -o bin/$* ./cmd/$*
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个规则将编译 <code>cmd</code> 目录下的 Go 程序，并将编译结果放置到 <code>bin</code> 目录中。例如，如果输入 <code>make build.server</code>，那么将编译 <code>cmd/server</code> 目录下的 Go 程序，并将编译结果放置到 <code>bin/server</code> 目录中。</p></blockquote><p><strong>条件语句：</strong></p><p>Makefile 也支持条件语句。这里先看一个示例。</p><p>下面的例子判断变量ROOT_PACKAGE是否为空，如果为空，则输出错误信息，不为空则打印变量值：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>ROOT_PACKAGE<span class="token punctuation">)</span>,<span class="token punctuation">)</span>
<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">error</span> the variable ROOT_PACKAGE must be set prior to including golang.mk<span class="token punctuation">)</span>
<span class="token keyword">else</span>
<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">info</span> the value of ROOT_PACKAGE is <span class="token variable">$</span><span class="token punctuation">(</span>ROOT_PACKAGE<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>条件语句的语法为：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token comment"># if ...</span>
&lt;conditional-directive&gt;
&lt;text-if-true&gt;
<span class="token keyword">endif</span>
<span class="token comment"># if ... else ...</span>
&lt;conditional-directive&gt;
&lt;text-if-true&gt;
<span class="token keyword">else</span>
&lt;text-if-false&gt;
<span class="token keyword">endif</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>例如，判断两个值是否相等：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">ifeq</span> 条件表达式
...
<span class="token keyword">else</span>
...
<span class="token keyword">endif</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>ifeq 表示条件语句的开始，并指定一个条件表达式。表达式包含两个参数，参数之间用逗号分隔，并且表达式用圆括号括起来。</li><li>else 表示条件表达式为假的情况。</li><li>endif 表示一个条件语句的结束，任何一个条件表达式都应该以 endif 结束。</li><li>表示条件关键字，有 4 个关键字：ifeq、ifneq、ifdef、ifndef。</li></ul><p><strong>为了加深你的理解，我们分别来看下这 4 个关键字的例子。</strong></p><p>ifeq：条件判断，判断是否相等。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">ifeq</span> <span class="token punctuation">(</span>&lt;arg1&gt;, &lt;arg2&gt;<span class="token punctuation">)</span>
<span class="token keyword">ifeq</span> <span class="token string">&#39;&lt;arg1&gt;&#39;</span> <span class="token string">&#39;&lt;arg2&gt;&#39;</span>
<span class="token keyword">ifeq</span> <span class="token string">&quot;&lt;arg1&gt;&quot;</span> <span class="token string">&quot;&lt;arg2&gt;&quot;</span>
<span class="token keyword">ifeq</span> <span class="token string">&quot;&lt;arg1&gt;&quot;</span> <span class="token string">&#39;&lt;arg2&gt;&#39;</span>
<span class="token keyword">ifeq</span> <span class="token string">&#39;&lt;arg1&gt;&#39;</span> <span class="token string">&quot;&lt;arg2&gt;&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比较 arg1 和 arg2 的值是否相同，如果相同则为真。也可以用 make 函数 / 变量替代 arg1 或 arg2，例如 <code>ifeq ($(origin ROOT_DIR),undefined) </code>或 <code>ifeq ($(ROOT_PACKAGE),)</code> 。origin 函数会在之后专门讲函数的一讲中介绍到。</p><p>ifneq：条件判断，判断是否不相等。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">ifneq</span> <span class="token punctuation">(</span>&lt;arg1&gt;, &lt;arg2&gt;<span class="token punctuation">)</span>
<span class="token keyword">ifneq</span> <span class="token string">&#39;&lt;arg1&gt;&#39;</span> <span class="token string">&#39;&lt;arg2&gt;&#39;</span>
<span class="token keyword">ifneq</span> <span class="token string">&quot;&lt;arg1&gt;&quot;</span> <span class="token string">&quot;&lt;arg2&gt;&quot;</span>
<span class="token keyword">ifneq</span> <span class="token string">&quot;&lt;arg1&gt;&quot;</span> <span class="token string">&#39;&lt;arg2&gt;&#39;</span>
<span class="token keyword">ifneq</span> <span class="token string">&#39;&lt;arg1&gt;&#39;</span> <span class="token string">&quot;&lt;arg2&gt;&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比较 arg1 和 arg2 的值是否不同，如果不同则为真。</p><p>ifdef：条件判断，判断变量是否已定义。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">ifdef</span> &lt;variable-name&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果值非空，则表达式为真，否则为假。也可以是函数的返回值。</p><p>ifndef：条件判断，判断变量是否未定义。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>ifndef &lt;variable-name&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果值为空，则表达式为真，否则为假。也可以是函数的返回值。</p><h3 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h3><p>我们先来看下自定义函数。 make 解释器提供了一系列的函数供 Makefile 调用，这些函数是 Makefile 的预定义函数。我们可以通过 define 关键字来自定义一个函数。自定义函数的语法为：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">define</span> 函数名
函数体
<span class="token keyword">endef</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>💡简单的一个案例如下：</strong></p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">define</span> Foo
    <span class="token operator">@</span>echo <span class="token string">&quot;my name is $(0)&quot;</span>
    <span class="token operator">@</span>echo <span class="token string">&quot;param is $(1)&quot;</span>
<span class="token keyword">endef</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>define 本质上是定义一个多行变量，可以在 call 的作用下当作函数来使用，在其他位置使用只能作为多行变量来使用，例如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>var :<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>call Foo<span class="token variable">)</span></span>
new :<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>Foo<span class="token variable">)</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>预定义函数：</strong></p><p>再来看下预定义函数。 刚才提到，make 编译器也定义了很多函数，这些函数叫作预定义函数，调用语法和变量类似，语法为：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token variable"><span class="token variable">$(</span><span class="token operator">&lt;</span>function<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>arguments<span class="token operator">&gt;</span><span class="token variable">)</span></span>
OR
<span class="token variable">${&lt;function&gt; &lt;arguments&gt;}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>&lt;function&gt; </code> 是函数名，<code>&lt;arguments&gt;</code> 是函数参数，参数间用逗号分割。函数的参数也可以是变量。</p><p>💡简单的一个案例如下：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>PLATFORM <span class="token operator">=</span> linux_amd64
GOOS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">word</span> 1, <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> _, ,<span class="token variable">$</span><span class="token punctuation">(</span>PLATFORM<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子用到了两个函数：word 和 subst。word 函数有两个参数，1 和 subst 函数的输出。subst 函数将 PLATFORM 变量值中的 <code>_</code> 替换成空格（替换后的 PLATFORM 值为 linux amd64）。word 函数取 <code>linux amd64</code> 字符串中的第一个单词。所以最后 GOOS 的值为 linux。</p><p>Makefile 预定义函数能够帮助我们实现很多强大的功能，在编写 Makefile 的过程中，如果有功能需求，可以优先使用这些函数。如果你想使用这些函数，那就需要知道有哪些函数，以及它们实现的功能。</p><p><img src="http://sm.nsddd.top/sm202302201721492.jpeg" alt="img"></p><h3 id="引入其他-makefile" tabindex="-1"><a class="header-anchor" href="#引入其他-makefile" aria-hidden="true">#</a> 引入其他 Makefile</h3><p>在 Makefile 中，我们可以通过关键字 include，把别的 makefile 包含进来，类似于 C 语言的<code>#include</code>，被包含的文件会插入在当前的位置。include 用法为 include ，示例如下：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">include</span> scripts/make-rules/common.mk
<span class="token keyword">include</span> scripts/make-rules/golang.mk
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>include 也可以包含通配符<code>include scripts/make-rules/*</code>。make 命令会按下面的顺序查找 makefile 文件：</p><ul><li>如果是绝对或相对路径，就直接根据路径 include 进来。</li><li>如果 make 执行时，有<code>-I</code>或<code>--include-dir</code>参数，那么 make 就会在这个参数所指定的目录下去找。</li><li>如果目录<code>&lt;prefix&gt;/include</code>（一般是/usr/local/bin或/usr/include）存在的话，make 也会去找。</li></ul><p>如果有文件没有找到，make 会生成一条警告信息，但不会马上出现致命错误，而是继续载入其他的文件。一旦完成 makefile 的读取，make 会再重试这些没有找到或是不能读取的文件。如果还是不行，make 才会出现一条致命错误信息。如果你想让 <code>make</code> 忽略那些无法读取的文件继续执行，可以在 include 前加一个减号<code>-</code>，如<code>-include</code> 。</p><h2 id="设计makefile结构" tabindex="-1"><a class="header-anchor" href="#设计makefile结构" aria-hidden="true">#</a> 设计Makefile结构</h2><p>对于大型项目来说，需要管理的内容很多，所有管理功能都集成在一个 Makefile 中，可能会导致 Makefile 很大，难以阅读和维护，所以建议采用分层的设计方法，<strong>根目录下的 Makefile 聚合所有的 Makefile 命令，具体实现则按功能分类，放在另外的 Makefile 中。</strong></p><p>我们经常会在 Makefile 命令中集成 shell 脚本，但如果 shell 脚本过于复杂，也会导致 Makefile 内容过多，难以阅读和维护。并且在 Makefile 中集成复杂的 shell 脚本，编写体验也很差。对于这种情况，<strong>可以将复杂的 shell 命令封装在 shell 脚本中，供 Makefile 直接调用，而一些简单的命令则可以直接集成在 Makefile 中。</strong></p><p><strong>推荐的 Makefile 结构：</strong></p><p><img src="https://sm.nsddd.top/sm202302191533699.png" alt="image-20230219153332640"></p><p>在上面的 Makefile 组织方式中，根目录下的 Makefile 聚合了项目所有的管理功能，这些管理功能通过 Makefile 伪目标的方式实现。同时，还将这些伪目标进行分类，把相同类别的伪目标放在同一个 Makefile 中，这样可以使得 Makefile 更容易维护。对于复杂的命令，则编写成独立的 shell 脚本，并在 Makefile 命令中调用这些 shell 脚本。</p><p>举个例子，下面是 IAM 项目的 Makefile 组织结构：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>
├── Makefile
├── scripts
│   ├── gendoc.sh
│   ├── make-rules
│   │   ├── gen.mk
│   │   ├── golang.mk
│   │   ├── image.mk
│   │   └── <span class="token punctuation">..</span>.
    └── <span class="token punctuation">..</span>.
├── Makefile
├── scripts
│   ├── gendoc.sh
│   ├── make-rules
│   │   ├── gen.mk
│   │   ├── golang.mk
│   │   ├── image.mk
│   │   └── <span class="token punctuation">..</span>.
    └── <span class="token punctuation">..</span>.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们将相同类别的操作统一放在 <code>scripts/make-rules</code> 目录下的 Makefile 文件中。<strong>Makefile 的文件名参考分类命名</strong>，例如 <code>golang.mk</code>。最后，在 <code>/Makefile</code> 中 include 这些 Makefile。</p><blockquote><p>需要使用 <code>include</code> 来获取头文件：</p><p><code>include</code>是一种指令，用于将另一个文件中的规则和变量导入到当前的makefile中。这样做可以让你的makefile更加模块化，易于维护和重用。</p><p><strong>注意和我们上面讲的模块化分配 Makefile 层级调用有些不一样。</strong></p><p>下面是一个include的案例，假设我们有一个名为<code>main.c</code>的源文件，它需要链接一个名为<code>libfoo.a</code>的静态库文件。我们可以将这些规则和变量定义在一个名为<code>Makefile.inc</code>的文件中，然后在我们的主makefile中使用include指令将其导入。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>CC <span class="token operator">=</span> gcc
CFLAGS <span class="token operator">=</span> -Wall -Werror -g

<span class="token target symbol">all</span><span class="token punctuation">:</span> libfoo.a

<span class="token target symbol">libfoo.a</span><span class="token punctuation">:</span> foo.o
	ar rcs <span class="token variable">$@</span> <span class="token variable">$^</span>

<span class="token target symbol">foo.o</span><span class="token punctuation">:</span> foo.c foo.h
	<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span>

<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	rm -f *.o libfoo.a

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主makefile文件：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">include</span> Makefile.inc

<span class="token target symbol">main</span><span class="token punctuation">:</span> main.c libfoo.a
	<span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$&lt;</span> -L. -lfoo

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
	<span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> -C . -f Makefile.inc clean
	rm -f main
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>go 语言Makefile 💡简单的一个案例如下：</strong></p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token comment"># 定义变量</span>
GOCMD<span class="token operator">=</span>go
GOBUILD<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>GOCMD<span class="token punctuation">)</span> build
GOCLEAN<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>GOCMD<span class="token punctuation">)</span> clean
BINARY_NAME<span class="token operator">=</span>myapp
BINARY_UNIX<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>BINARY_NAME<span class="token punctuation">)</span>_unix

<span class="token target symbol">all</span><span class="token punctuation">:</span> deps build
<span class="token target symbol">build</span><span class="token punctuation">:</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>GOBUILD<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>BINARY_NAME<span class="token punctuation">)</span> -v
    <span class="token variable">$</span><span class="token punctuation">(</span>GOBUILD<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>BINARY_UNIX<span class="token punctuation">)</span> -v
<span class="token target symbol">deps</span><span class="token punctuation">:</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>GOCMD<span class="token punctuation">)</span> get -u github.com/golang/dep/cmd/dep
    dep ensure
<span class="token target symbol">clean</span><span class="token punctuation">:</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>GOCLEAN<span class="token punctuation">)</span>
    rm -f <span class="token variable">$</span><span class="token punctuation">(</span>BINARY_NAME<span class="token punctuation">)</span>
    rm -f <span class="token variable">$</span><span class="token punctuation">(</span>BINARY_UNIX<span class="token punctuation">)</span>
<span class="token target symbol">run</span><span class="token punctuation">:</span>
    <span class="token variable">$</span><span class="token punctuation">(</span>GOBUILD<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>BINARY_NAME<span class="token punctuation">)</span> -v ./...
    ./<span class="token variable">$</span><span class="token punctuation">(</span>BINARY_NAME<span class="token punctuation">)</span>
<span class="token keyword">include</span> docker.mk

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的示例中，最后一行 <code>include docker.mk</code> 引用了名为 <code>docker.mk</code> 的 Makefile 文件。这个文件中可能包含了一些 Docker 相关的命令，比如构建镜像、推送镜像等等。通过 include 指令，这些命令可以被自动引入到主 Makefile 文件中，从而实现更加高效和便捷的编译和构建。</p><p>需要注意的是，include 指令的作用是将被引入的 Makefile 文件的内容直接复制到主 Makefile 文件中。因此，如果引入的文件中定义了和主 Makefile 文件中相同的变量或者规则，会发生命名冲突。因此，在编写被引入的 Makefile 文件时，应该避免使用和主 Makefile 文件相同的变量和规则名。</p></blockquote><p>为了跟 Makefile 的层级相匹配，<code>golang.mk</code> 中的所有目标都按<code>go.xxx</code>这种方式命名。通过这种命名方式，我们可以很容易分辨出某个目标完成什么功能，放在什么文件里，这在复杂的 Makefile 中尤其有用。以下是 IAM 项目根目录下，Makefile 的内容摘录，你可以看一看，作为参考：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">include</span> scripts/make-rules/golang.mk
<span class="token keyword">include</span> scripts/make-rules/image.mk
<span class="token keyword">include</span> scripts/make-rules/gen.mk
<span class="token keyword">include</span> scripts/make-rules/...

<span class="token comment">## build: Build source code for host platform.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build
<span class="token target symbol">build</span><span class="token punctuation">:</span>
  <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> go.build

<span class="token comment">## build.multiarch: Build source code for multiple platforms. See option PLATFORMS.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> build.multiarch
<span class="token target symbol">build.multiarch</span><span class="token punctuation">:</span>
  <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> go.build.multiarch

<span class="token comment">## image: Build docker images for host arch.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> image
<span class="token target symbol">image</span><span class="token punctuation">:</span>
  <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> image.build

<span class="token comment">## push: Build docker images for host arch and push images to registry.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> push
<span class="token target symbol">push</span><span class="token punctuation">:</span>
  <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> image.push

<span class="token comment">## ca: Generate CA files for all iam components.</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> ca
<span class="token target symbol">ca</span><span class="token punctuation">:</span>
  <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> gen.ca
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，一个合理的 Makefile 结构应该具有前瞻性。也就是说，要在不改变现有结构的情况下，接纳后面的新功能。这就需要你整理好 Makefile 当前要实现的功能、即将要实现的功能和未来可能会实现的功能，然后基于这些功能，利用 Makefile 编程技巧，编写可扩展的 Makefile。</p><p>这里需要你注意：上面的 Makefile 通过 <code>.PHONY</code> 标识定义了大量的伪目标，定义伪目标一定要加 <code>.PHONY</code> 标识，否则当有同名的文件时，伪目标可能不会被执行。</p><h2 id="掌握-makefile-编写技巧" tabindex="-1"><a class="header-anchor" href="#掌握-makefile-编写技巧" aria-hidden="true">#</a> 掌握 Makefile 编写技巧</h2><h3 id="技巧-1-善用通配符和自动变量" tabindex="-1"><a class="header-anchor" href="#技巧-1-善用通配符和自动变量" aria-hidden="true">#</a> 技巧 1：善用通配符和自动变量</h3><p>Makefile 允许对目标进行类似正则运算的匹配，主要用到的通配符是%。通过使用通配符，可以使不同的目标使用相同的规则，从而使 Makefile 扩展性更强，也更简洁。</p><p>我们的 IAM 实战项目中，就大量使用了通配符<code>%</code>，例如：<code>go.build.%</code>、<code>ca.gen.%</code>、<code>deploy.run.%</code>、<code>tools.verify.%</code>、<code>tools.install.%</code>等。</p><p>这里，我们来看一个具体的例子，<code>tools.verify.%</code>（位于<code>scripts/make-rules/tools.mk</code>文件中）定义如下：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token target symbol">tools.verify.%</span><span class="token punctuation">:</span>
  <span class="token operator">@</span>if ! which <span class="token variable">$*</span> &amp;&gt;/dev/null<span class="token punctuation">;</span> then <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> tools.install.<span class="token variable">$*;</span> fi
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>make tools.verify.swagger</code>, <code>make tools.verify.mockgen</code>等均可以使用上面定义的规则，%分别代表了<code>swagger</code>和<code>mockgen</code>。</p><p>如果不使用<code>%</code>，则我们需要分别为<code>tools.verify.swagger</code>和<code>tools.verify.mockgen</code>定义规则，很麻烦，后面修改也困难。</p><p>另外，这里也能看出<code>tools.verify.%</code>这种命名方式的好处：</p><ul><li>tools 说明依赖的定义位于<code>scripts/make-rules/tools.mk</code> Makefile 中；</li><li>verify说明<code>tools.verify.%</code>伪目标属于 verify 分类，主要用来验证工具是否安装。通过这种命名方式，你可以很容易地知道目标位于哪个 Makefile 文件中，以及想要完成的功能。</li></ul><p>另外，上面的定义中还用到了自动变量<code>$*</code>，用来指代被匹配的值<code>swagger</code>、<code>mockgen</code>。</p><h3 id="技巧-2-善用函数" tabindex="-1"><a class="header-anchor" href="#技巧-2-善用函数" aria-hidden="true">#</a> 技巧 2：善用函数</h3><p>Makefile 自带的函数能够帮助我们实现很多强大的功能。所以，在我们编写 Makefile 的过程中，如果有功能需求，可以优先使用这些函数。我把常用的函数以及它们实现的功能整理在了 <a href="https://github.com/marmotedu/geekbang-go/blob/master/makefile/Makefile%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.md" target="_blank" rel="noopener noreferrer">Makefile<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 常用函数列表 中，你可以参考下。</p><p>IAM 的 Makefile 文件中大量使用了上述函数，如果你想查看这些函数的具体使用方法和场景，可以参考 IAM 项目的 Makefile 文件 <code>make-rules</code>。</p><h3 id="技巧-3-依赖需要用到的工具" tabindex="-1"><a class="header-anchor" href="#技巧-3-依赖需要用到的工具" aria-hidden="true">#</a> 技巧 3：依赖需要用到的工具</h3><p>如果 Makefile 某个目标的命令中用到了某个工具，可以将该工具放在目标的依赖中。这样，当执行该目标时，就可以指定检查系统是否安装该工具，如果没有安装则自动安装，从而实现更高程度的自动化。例如，<code>/Makefile</code> 文件中，<code>format</code> 伪目标，定义如下：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>.PHONY: <span class="token function">format</span>
format: tools.verify.golines tools.verify.goimports
  @echo <span class="token string">&quot;===========&gt; Formating codes&quot;</span>
  @<span class="token variable"><span class="token variable">$(</span>FIND<span class="token variable">)</span></span> <span class="token parameter variable">-type</span> f <span class="token parameter variable">-name</span> <span class="token string">&#39;*.go&#39;</span> <span class="token operator">|</span> <span class="token variable"><span class="token variable">$(</span>XARGS<span class="token variable">)</span></span> gofmt <span class="token parameter variable">-s</span> <span class="token parameter variable">-w</span>
  @<span class="token variable"><span class="token variable">$(</span>FIND<span class="token variable">)</span></span> <span class="token parameter variable">-type</span> f <span class="token parameter variable">-name</span> <span class="token string">&#39;*.go&#39;</span> <span class="token operator">|</span> <span class="token variable"><span class="token variable">$(</span>XARGS<span class="token variable">)</span></span> goimports <span class="token parameter variable">-w</span> <span class="token parameter variable">-local</span> <span class="token variable"><span class="token variable">$(</span>ROOT_PACKAGE<span class="token variable">)</span></span>
  @<span class="token variable"><span class="token variable">$(</span>FIND<span class="token variable">)</span></span> <span class="token parameter variable">-type</span> f <span class="token parameter variable">-name</span> <span class="token string">&#39;*.go&#39;</span> <span class="token operator">|</span> <span class="token variable"><span class="token variable">$(</span>XARGS<span class="token variable">)</span></span> golines <span class="token parameter variable">-w</span> --max-len<span class="token operator">=</span><span class="token number">120</span> --reformat-tags --shorten-comments --ignore-generated <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以看到，format 依赖<code>tools.verify.golines tools.verify.goimports</code>。我们再来看下<code>tools.verify.golines</code>的定义：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>tools.verify.%:
  @if <span class="token operator">!</span> <span class="token function">which</span> <span class="token variable">$*</span> <span class="token operator">&amp;&gt;</span>/dev/null<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> tools.install.<span class="token variable">$*</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>再来看下<code>tools.install.$*</code>规则：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>.PHONY: install.golines
install.golines:
  @<span class="token variable"><span class="token variable">$(</span>GO<span class="token variable">)</span></span> get <span class="token parameter variable">-u</span> github.com/segmentio/golines
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过<code>tools.verify.%</code>规则定义，我们可以知道，<code>tools.verify.%</code>会先检查工具是否安装，如果没有安装，就会执行<code>tools.install.$*</code>来安装。如此一来，当我们执行<code>tools.verify.%</code>目标时，如果系统没有安装 golines 命令，就会自动调用 go get安装，提高了 Makefile 的自动化程度。</p><h3 id="技巧-4-把常用功能放在-makefile-中-不常用的放在分类-makefile-中" tabindex="-1"><a class="header-anchor" href="#技巧-4-把常用功能放在-makefile-中-不常用的放在分类-makefile-中" aria-hidden="true">#</a> 技巧 4：把常用功能放在 /Makefile 中，不常用的放在分类 Makefile 中</h3><p>一个项目，尤其是大型项目，有很多需要管理的地方，其中大部分都可以通过 Makefile 实现自动化操作。不过，为了保持 <code>/Makefile</code> 文件的整洁性，我们不能把所有的命令都添加在 <code>/Makefile</code> 文件中。</p><p>一个比较好的建议是，将常用功能放在 <code>/Makefile</code> 中，不常用的放在分类 Makefile 中，并在 <code>/Makefile</code> 中 include 这些分类 Makefile。</p><p>例如，IAM 项目的 <code>/Makefile</code> 集成了format、lint、test、build等常用命令，而将<code>gen.errcode.code、gen.errcode.doc</code>这类不常用的功能放在 <code>scripts/make-rules/gen.mk</code> 文件中。当然，我们也可以直接执行 <code>make gen.errcode.code</code>来执行<code>gen.errcode.code</code>伪目标。通过这种方式，既可以保证 <code>/Makefile</code> 的简洁、易维护，又可以通过make命令来运行伪目标，更加灵活。</p><h3 id="技巧-5-编写可扩展的-makefile" tabindex="-1"><a class="header-anchor" href="#技巧-5-编写可扩展的-makefile" aria-hidden="true">#</a> 技巧 5：编写可扩展的 Makefile</h3><p>什么叫可扩展的 Makefile 呢？在我看来，可扩展的 Makefile 包含两层含义：</p><ul><li>可以在不改变 Makefile 结构的情况下添加新功能。</li><li>扩展项目时，新功能可以自动纳入到 Makefile 现有逻辑中。</li></ul><p>其中的第一点，我们可以通过设计合理的 Makefile 结构来实现。要实现第二点，就需要我们在编写 Makefile 时采用一定的技巧，例如多用通配符、自动变量、函数等。这里我们来看一个例子，可以让你更好地理解。</p><p>在我们 IAM 实战项目的golang.mk中，执行 <code>make go.build</code> 时能够构建 <code>cmd/</code> 目录下的所有组件，也就是说，当有新组件添加时， <code>make go.build</code> 仍然能够构建新增的组件，这就实现了上面说的第二点。</p><p>具体实现方法如下：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>COMMANDS <span class="token operator">?=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">filter-out</span> %.md, <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">wildcard</span> <span class="token variable">$</span><span class="token punctuation">{</span>ROOT_DIR<span class="token punctuation">}</span>/cmd/*<span class="token punctuation">)</span><span class="token punctuation">)</span>
BINS <span class="token operator">?=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">foreach</span> cmd,<span class="token variable">$</span><span class="token punctuation">{</span>COMMANDS<span class="token punctuation">}</span>,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">notdir</span> <span class="token variable">$</span><span class="token punctuation">{</span>cmd<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> go.build
<span class="token target symbol">go.build</span><span class="token punctuation">:</span> go.build.verify <span class="token variable">$</span><span class="token punctuation">(</span>addprefix go.build., <span class="token variable">$</span><span class="token punctuation">(</span>addprefix <span class="token variable">$</span><span class="token punctuation">(</span>PLATFORM<span class="token punctuation">)</span>., <span class="token variable">$</span><span class="token punctuation">(</span>BINS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> go.build.%               

<span class="token target symbol">go.build.%</span><span class="token punctuation">:</span>             
  <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">eval</span> COMMAND <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">word</span> 2,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> ., ,<span class="token variable">$*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">eval</span> PLATFORM <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">word</span> 1,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> ., ,<span class="token variable">$*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">eval</span> OS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">word</span> 1,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> _, ,<span class="token variable">$</span><span class="token punctuation">(</span>PLATFORM<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           
  <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">eval</span> ARCH <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">word</span> 2,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">subst</span> _, ,<span class="token variable">$</span><span class="token punctuation">(</span>PLATFORM<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                         
  <span class="token operator">@</span>echo <span class="token string">&quot;===========&gt; Building binary $(COMMAND) $(VERSION) for $(OS) $(ARCH)&quot;</span>
  <span class="token operator">@</span>mkdir -p <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT_DIR<span class="token punctuation">)</span>/platforms/<span class="token variable">$</span><span class="token punctuation">(</span>OS<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">(</span>ARCH<span class="token punctuation">)</span>
  <span class="token operator">@</span>CGO_ENABLED<span class="token operator">=</span>0 GOOS<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>OS<span class="token punctuation">)</span> GOARCH<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>ARCH<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>GO<span class="token punctuation">)</span> build <span class="token variable">$</span><span class="token punctuation">(</span>GO_BUILD_FLAGS<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>OUTPUT_DIR<span class="token punctuation">)</span>/platforms/<span class="token variable">$</span><span class="token punctuation">(</span>OS<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">(</span>ARCH<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">(</span>COMMAND<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>GO_OUT_EXT<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>ROOT_PACKAGE<span class="token punctuation">)</span>/cmd/<span class="token variable">$</span><span class="token punctuation">(</span>COMMAND<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当执行make go.build 时，会执行 go.build 的依赖 <code>$(addprefix go.build., $(addprefix $(PLATFORM)., $(BINS))</code>) ,<code>addprefix</code>函数最终返回字符串 <code>go.build.linux_amd64.iamctl go.build.linux_amd64.iam-authz-server go.build.linux_amd64.iam-apiserver ...</code> ，这时候就会执行 <code>go.build.%</code> 伪目标。</p><p>在 <code>go.build.%</code> 伪目标中，通过 eval、word、subst 函数组合，算出了 COMMAND 的值 <code>iamctl/iam-apiserver/iam-authz-server/...</code>，最终通过 <code>$(ROOT_PACKAGE)/cmd/$(COMMAND)</code> 定位到需要构建的组件的 main 函数所在目录。</p><p>上述实现中有两个技巧，你可以注意下。首先，通过</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>COMMANDS ?<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>filter-out %.md, <span class="token punctuation">$(</span>wildcard $<span class="token punctuation">{</span>ROOT_DIR<span class="token punctuation">}</span>/cmd/*<span class="token punctuation">)</span><span class="token variable">)</span></span>
BINS ?<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>foreach cmd,$<span class="token punctuation">{</span>COMMANDS<span class="token punctuation">}</span>,<span class="token punctuation">$(</span>notdir $<span class="token punctuation">{</span>cmd<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token variable">)</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>获取到了 <code>cmd/</code> 目录下的所有组件名。</p><p>接着，通过使用通配符和自动变量，自动匹配到<code>go.build.linux_amd64.iam-authz-server</code> 这类伪目标并构建。</p><p>可以看到，想要编写一个可扩展的 Makefile，熟练掌握 Makefile 的用法是基础，更多的是需要我们动脑思考如何去编写 Makefile。</p><h3 id="技巧-6-将所有输出存放在一个目录下-方便清理和查找" tabindex="-1"><a class="header-anchor" href="#技巧-6-将所有输出存放在一个目录下-方便清理和查找" aria-hidden="true">#</a> 技巧 6：将所有输出存放在一个目录下，方便清理和查找</h3><p>在执行 Makefile 的过程中，会输出各种各样的文件，例如 Go 编译后的二进制文件、测试覆盖率数据等，我建议你把这些文件统一放在一个目录下，方便后期的清理和查找。通常我们可以把它们放在<code>_output</code>这类目录下，这样清理时就很方便，只需要清理<code>_output</code>文件夹就可以，例如：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>.PHONY: go.clean
go.clean:
  @echo <span class="token string">&quot;===========&gt; Cleaning all build output&quot;</span>
  @-rm <span class="token parameter variable">-vrf</span> <span class="token variable"><span class="token variable">$(</span>OUTPUT_DIR<span class="token variable">)</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里要注意，要用<code>-rm</code>，而不是 rm，防止在没有<code>_output</code>目录时，执行<code>make go.clean</code>报错。</p><h3 id="技巧-7-使用带层级的命名方式" tabindex="-1"><a class="header-anchor" href="#技巧-7-使用带层级的命名方式" aria-hidden="true">#</a> 技巧 7：使用带层级的命名方式</h3><p>通过使用带层级的命名方式，例如<code>tools.verify.swagger</code> ，我们可以实现目标分组管理。这样做的好处有很多。首先，当 Makefile 有大量目标时，通过分组，我们可以更好地管理这些目标。其次，分组也能方便理解，可以通过组名一眼识别出该目标的功能类别。最后，这样做还可以大大减小目标重名的概率。</p><p>例如，IAM 项目的 Makefile 就大量采用了下面这种命名方式。</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> gen.run
<span class="token target symbol">gen.run</span><span class="token punctuation">:</span> gen.clean gen.errcode gen.docgo

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> gen.errcode
<span class="token target symbol">gen.errcode</span><span class="token punctuation">:</span> gen.errcode.code gen.errcode.doc

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> gen.errcode.code
<span class="token target symbol">gen.errcode.code</span><span class="token punctuation">:</span> tools.verify.codegen
    ...
<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> gen.errcode.doc
<span class="token target symbol">gen.errcode.doc</span><span class="token punctuation">:</span> tools.verify.codegen
    ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="技巧-8-做好目标拆分" tabindex="-1"><a class="header-anchor" href="#技巧-8-做好目标拆分" aria-hidden="true">#</a> 技巧 8：做好目标拆分</h3><p>还有一个比较实用的技巧：我们要合理地拆分目标。比如，我们可以将安装工具拆分成两个目标：验证工具是否已安装和安装工具。通过这种方式，可以给我们的 Makefile 带来更大的灵活性。例如：我们可以根据需要选择性地执行其中一个操作，也可以两个操作一起执行。</p><p>这里来看一个例子：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token target symbol">gen.errcode.code</span><span class="token punctuation">:</span> tools.verify.codegen

<span class="token target symbol">tools.verify.%</span><span class="token punctuation">:</span>    
  <span class="token operator">@</span>if ! which <span class="token variable">$*</span> &amp;&gt;/dev/null<span class="token punctuation">;</span> then <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span> tools.install.<span class="token variable">$*;</span> fi  

<span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> install.codegen
<span class="token target symbol">install.codegen</span><span class="token punctuation">:</span>              
  <span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>GO<span class="token punctuation">)</span> install <span class="token variable">$</span><span class="token punctuation">{</span>ROOT_DIR<span class="token punctuation">}</span>/tools/codegen/codegen.go
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的 Makefile 中，<code>gen.errcode.code</code> 依赖了 <code>tools.verify.codegen</code>，<code>tools.verify.codegen</code> 会先检查 codegen 命令是否存在，如果不存在，再调用 <code>install.codegen</code> 来安装 <code>codegen</code> 工具。</p><p>如果我们的 Makefile 设计是：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>gen.errcode.code: install.codegen
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>那每次执行 <code>gen.errcode.code</code> 都要重新安装 codegen 命令，这种操作是不必要的，还会导致 make gen.errcode.code 执行很慢。</p><h3 id="技巧-9-设置-options" tabindex="-1"><a class="header-anchor" href="#技巧-9-设置-options" aria-hidden="true">#</a> 技巧 9：设置 OPTIONS</h3><p>编写 Makefile 时，我们还需要把一些可变的功能通过 OPTIONS 来控制。为了帮助你理解，这里还是拿 IAM 项目的 Makefile 来举例。</p><p>假设我们需要通过一个选项 V ，来控制是否需要在执行 Makefile 时打印详细的信息。这可以通过下面的步骤来实现。</p><p>首先，在 <code>/Makefile</code> 中定义 <code>USAGE_OPTIONS</code> 。定义 <code>USAGE_OPTIONS</code> 可以使开发者在执行 make help 后感知到此 OPTION，并根据需要进行设置。</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>define USAGE_OPTIONS    
                         
Options:
  <span class="token punctuation">..</span>.
  BINS         The binaries to build. Default is all of cmd.
               <span class="token punctuation">..</span>.
  <span class="token punctuation">..</span>.
  V            Set to <span class="token number">1</span> <span class="token builtin class-name">enable</span> verbose build. Default is <span class="token number">0</span>.    
endef    
<span class="token builtin class-name">export</span> USAGE_OPTIONS    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着，在<code>scripts/make-rules/common.mk</code>文件中，我们通过判断有没有设置 V 选项，来选择不同的行为：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token keyword">ifndef</span> V    
MAKEFLAGS <span class="token operator">+=</span> --no-print-directory    
<span class="token keyword">endif</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，我们还可以通过下面的方法来使用 V ：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>ifeq <span class="token punctuation">(</span><span class="token variable"><span class="token variable">$(</span>origin V<span class="token variable">)</span></span>, undefined<span class="token punctuation">)</span> 
MAKEFLAGS <span class="token operator">+=</span> --no-print-directory              
endif
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面，我介绍了 <code>VOPTION</code>，我们在 <code>Makefile</code> 中通过判断有没有定义 <code>V</code> ，来执行不同的操作。其实还有一种 <code>OPTION</code>，这种 <code>OPTION</code> 的值我们在 Makefile 中是直接使用的，例如 <code>BINS</code>。针对这种 <code>OPTION</code>，我们可以通过以下方式来使用：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>BINS ?<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>foreach cmd,$<span class="token punctuation">{</span>COMMANDS<span class="token punctuation">}</span>,<span class="token punctuation">$(</span>notdir $<span class="token punctuation">{</span>cmd<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token variable">)</span></span>
<span class="token punctuation">..</span>.
go.build: go.build.verify <span class="token variable"><span class="token variable">$(</span>addprefix go.build., <span class="token punctuation">$(</span>addprefix <span class="token punctuation">$(</span>PLATFORM<span class="token punctuation">)</span>., <span class="token punctuation">$(</span>BINS<span class="token punctuation">)</span><span class="token variable">)</span></span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，通过 <code>?=</code> 来判断 BINS 变量有没有被赋值，如果没有，则赋予等号后的值。接下来，就可以在 Makefile 规则中使用它。</p><h3 id="技巧-10-定义环境变量" tabindex="-1"><a class="header-anchor" href="#技巧-10-定义环境变量" aria-hidden="true">#</a> 技巧 10：定义环境变量</h3><p>我们可以在 Makefile 中定义一些环境变量，例如：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>GO <span class="token operator">:=</span> go                         
GO_SUPPORTED_VERSIONS <span class="token operator">?=</span> 1.13<span class="token operator">|</span>1.14<span class="token operator">|</span>1.15<span class="token operator">|</span>1.16<span class="token operator">|</span>1.17    
GO_LDFLAGS <span class="token operator">+=</span> -X <span class="token variable">$</span><span class="token punctuation">(</span>VERSION_PACKAGE<span class="token punctuation">)</span>.GitVersion<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>VERSION<span class="token punctuation">)</span> \    
  -X <span class="token variable">$</span><span class="token punctuation">(</span>VERSION_PACKAGE<span class="token punctuation">)</span>.GitCommit<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>GIT_COMMIT<span class="token punctuation">)</span> \       
  -X <span class="token variable">$</span><span class="token punctuation">(</span>VERSION_PACKAGE<span class="token punctuation">)</span>.GitTreeState<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>GIT_TREE_STATE<span class="token punctuation">)</span> \                          
  -X <span class="token variable">$</span><span class="token punctuation">(</span>VERSION_PACKAGE<span class="token punctuation">)</span>.BuildDate<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token function">shell</span> date -u +<span class="token string">&#39;%Y-%m-%dT%H:%M:%SZ&#39;</span><span class="token punctuation">)</span>    
<span class="token keyword">ifneq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>DLV<span class="token punctuation">)</span>,<span class="token punctuation">)</span>                                                                                                     
  GO_BUILD_FLAGS <span class="token operator">+=</span> -gcflags <span class="token string">&quot;all=-N -l&quot;</span>    
  LDFLAGS <span class="token operator">=</span> <span class="token string">&quot;&quot;</span>      
<span class="token keyword">endif</span>                                                                                   
GO_BUILD_FLAGS <span class="token operator">+=</span> -tags<span class="token operator">=</span>jsoniter -ldflags <span class="token string">&quot;$(GO_LDFLAGS)&quot;</span> 
...
FIND <span class="token operator">:=</span> find . ! -path <span class="token string">&#39;./third_party/*&#39;</span> ! -path <span class="token string">&#39;./vendor/*&#39;</span>    
XARGS <span class="token operator">:=</span> xargs --no-run-if-empty 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些环境变量和编程中使用宏定义的作用是一样的：只要修改一处，就可以使很多地方同时生效，避免了重复的工作。</p><p>通常，我们可以将 GO、GO_BUILD_FLAGS、FIND 这类变量定义为环境变量。</p><h3 id="技巧-11-自己调用自己" tabindex="-1"><a class="header-anchor" href="#技巧-11-自己调用自己" aria-hidden="true">#</a> 技巧 11：自己调用自己</h3><p>在编写 Makefile 的过程中，你可能会遇到这样一种情况：A-Target 目标命令中，需要完成操作 B-Action，而操作 B-Action 我们已经通过伪目标 B-Target 实现过。为了达到最大的代码复用度，这时候最好的方式是在 A-Target 的命令中执行 B-Target。方法如下：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>tools.verify.%:
  @if <span class="token operator">!</span> <span class="token function">which</span> <span class="token variable">$*</span> <span class="token operator">&amp;&gt;</span>/dev/null<span class="token punctuation">;</span> <span class="token keyword">then</span> <span class="token variable"><span class="token variable">$(</span>MAKE<span class="token variable">)</span></span> tools.install.<span class="token variable">$*</span><span class="token punctuation">;</span> <span class="token keyword">fi</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，我们通过 <code>$(MAKE)</code> 调用了伪目标 <code>tools.install.$*</code> 。要注意的是，默认情况下，Makefile 在切换目录时会输出以下信息：</p><div class="language-makefile ext-makefile line-numbers-mode"><pre class="language-makefile"><code>$ make tools.install.codegen
<span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span>&gt; Installing codegen
<span class="token target symbol">make[1]</span><span class="token punctuation">:</span> Entering directory `/home/colin/workspace/golang/src/github.com/marmotedu/iam&#39;
<span class="token target symbol">make[1]</span><span class="token punctuation">:</span> Leaving directory `/home/colin/workspace/golang/src/github.com/marmotedu/iam&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果觉得 Entering directory 这类信息很烦人，可以通过设置 <code>MAKEFLAGS += --no-print-directory</code> 来禁止 Makefile 打印这些信息。</p><h2 id="makefile-多线程" tabindex="-1"><a class="header-anchor" href="#makefile-多线程" aria-hidden="true">#</a> Makefile 多线程</h2><p>💡 <strong>注意，在设计Makefile的时候尤其注意对并行的设计，这一点非常重要~</strong></p><p>makefile是定义的依赖顺序,如果没有考虑多线程编译,很大概率会出问题。</p><p>Makefile 支持多线程并发操作，会极大的缩短我们的编译时间，并且当我们修改了源文件之后，编译整个工程的时候，make 命令只会编译我们修改过的文件，没有修改的文件不用重新编译，不增加或者是删除工程中的文件，Makefile 基本上不用去修改。</p><p><strong>因为CPU是一个影响编译速度的重要因素，所以make -j带上一个参数，可以把项目在进行中的并行编译，现在服务器上的CPU差不多都是多核多线程的，所以完全可以用make -j4，让make最多允许4个编译进程同时执行，这样可以更有效的利用CPU资源。</strong></p><p>在多处理器上运行多个作业显然是有意义的，但是在单处理器上运行多个作业也是非常有用的。这是因为磁盘I/O的延迟和大多数系统上的大量缓存。例如，如果诸如<code>gcc</code>的进程空闲等待盘I/O，则可能是诸如<code>mv</code>、<code>yacc</code>或<code>ar</code>的另一任务的数据当前在存储器中。在这种情况下，最好允许具有可用数据的任务继续进行。一般来说，在单处理器上运行两个任务的<code>make</code>几乎总是比运行一个任务快，并且三个甚至四个任务比两个任务快的情况并不少见。</p><p>使用<code>--jobs</code>=2告诉<code>make</code>在可能的情况下并行更新两个目标。</p><p><code>--jobs</code>选项可以不带数字使用。如果是这样，<code>make</code>将产生与要更新的目标一样多的作业。这通常是一个坏主意，因为大量的作业通常会淹没处理器，甚至比单个作业运行得慢得多。</p><p>💡简单的一个案例如下：</p><blockquote><p><strong>不用 <code>-j</code> 参数：</strong></p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>make linux-amd64  16.97s user 14.16s system 117% cpu 
26.595 total
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>使用 <code>-j</code> 参数：</strong></p></blockquote><p>cpu信息：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>cpu family      : 6
cpu MHz         : 2419.199
cpu cores       : 4
cpuid level     : 27
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>🚀 编译结果如下：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>make -j4 linux-amd64  9.35s user 2.97s system 104% cpu 11.772 total
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>📜 对上面的解释：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>make -j 6</td><td>使用6个并发进程编译</td></tr><tr><td>linux-amd64</td><td>编译的目标平台为linux-amd64</td></tr><tr><td>10.29s user</td><td>用户空间占用CPU时间10.29秒</td></tr><tr><td>4.31s system</td><td>内核空间占用CPU时间4.31秒</td></tr><tr><td>106% cpu</td><td>总CPU使用率为106%</td></tr><tr><td>13.774 total</td><td>总耗时13.774秒</td></tr></tbody></table><p><strong>使用的 subshell 也很重要，上面是对 zsh 的测试，而下面是 在 bash测试，至于Windows可以自己测试玩玩，应该更慢</strong></p><blockquote><p>这并不奇怪。Windows系统比Linux慢，<code>ash</code>比<code>bash</code>有优势。<code>ash</code>的性能提升更为明显-约快50<code>%</code>。Linux系统使用<code>ash</code>时性能最佳，使用<code>bash</code>（命名为“bash”时）时性能最慢。</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code># make -j4 linux-amd64 
real    0m11.284s
user    0m8.670s
sys     0m2.863s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们指定两个的测试：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code># make --jobs=2 linux-amd64
real    0m11.283s
user    0m8.502s
sys     0m2.901s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="makefile-参数" tabindex="-1"><a class="header-anchor" href="#makefile-参数" aria-hidden="true">#</a> Makefile 参数</h2><table><thead><tr><th>参数选项</th><th>功能</th></tr></thead><tbody><tr><td>-b，-m</td><td>忽略，提供其他版本 make 的兼容性</td></tr><tr><td>-B，–always-make</td><td>强制重建所有的规则目标，不根据规则的依赖描述决定是否重建目标文件。</td></tr><tr><td>-C DIR，–directory=DIR</td><td>在读取 Makefile 之前，进入到目录 DIR，然后执行 make。当存在多个 “-C” 选项的时候，make 的最终工作目录是第一个目录的相对路径。</td></tr><tr><td>-d</td><td>make 在执行的过程中打印出所有的调试信息，包括 make 认为那些文件需要重建，那些文件需要比较最后的修改时间、比较的结果，重建目标是用的命令，遗憾规则等等。使用 “-d” 选项我们可以看到 make 构造依赖关系链、重建目标过程中的所有的信息。</td></tr><tr><td><code>–debug[=OPTIONS]</code></td><td>make 执行时输出调试信息，可以使用 “OPTIONS” 控制调试信息的级别。默认是 “OPTIONS=b” ，“OPTIONS” 的可值为以下这些，首字母有效：all、basic、verbose、implicit、jobs、makefile。</td></tr><tr><td>-e，–enveronment -overrides</td><td>使用环境变量定义覆盖 Makefile 中的同名变量定义。</td></tr><tr><td>-f=FILE，–file=FILE， --makefile=FILE</td><td>指定文件 “FILE” 为 make 执行的 Makefile 文件</td></tr><tr><td>-p，–help</td><td>打印帮助信息。</td></tr><tr><td>-i，–ignore-errors</td><td>执行过程中忽略规则命令执行的错误。</td></tr><tr><td>-I DIR，–include-dir=DIR</td><td>指定包含 Makefile 文件的搜索目录，在Makefile中出现另一个 “include” 文件时，将在 “DIR” 目录下搜索。多个 “-i” 指定目录时，搜索目录按照指定的顺序进行。</td></tr><tr><td>-j [JOBS]，–jobs[=JOBS]</td><td>可指定同时执行的命令数目，没有 “-j” 的情况下，执行的命令数目将是系统允许的最大可能数目，存在多个 “-j” 目标时，最后一个目标指定的 JOBS 数有效。</td></tr><tr><td>-k，–keep-going</td><td>执行命令错误时不终止 make 的执行，make 尽最大可能执行所有的命令，直至出现知名的错误才终止。</td></tr><tr><td>-l load，–load-average=[=LOAD]，–max-load[=LOAD]</td><td>告诉 make 在存在其他任务执行的时候，如果系统负荷超过 “LOAD”，不在启动新的任务。如果没有指定 “LOAD” 的参数 “-l” 选项将取消之前 “-l” 指定的限制。</td></tr><tr><td>-n，–just-print，–dry-run</td><td>只打印执行的命令，但是不执行命令。</td></tr><tr><td>-o FILE，–old-file=FILE， --assume-old=FILE</td><td>指定 &quot;FILE&quot;文件不需要重建，即使是它的依赖已经过期；同时不重建此依赖文件的任何目标。注意：此参数不会通过变量 “MAKEFLAGS” 传递给子目录进程。</td></tr><tr><td>-p，–print-date-base</td><td>命令执行之前，打印出 make 读取的 Makefile 的所有数据，同时打印出 make 的版本信息。如果只需要打印这些数据信息，可以使用 “make -qp” 命令，查看 make 执行之前预设的规则和变量，可使用命令 “make -p -f /dev/null”</td></tr><tr><td>-q，-question</td><td>称为 “询问模式” ；不运行任何的命令，并且无输出。make 只返回一个查询状态。返回状态 0 表示没有目标表示重建，返回状态 1 表示存在需要重建的目标，返回状态 2 表示有错误发生。</td></tr><tr><td>-r，–no-builtin-rules</td><td>取消所有的内嵌函数的规则，不过你可以在 Makefile 中使用模式规则来定义规则。同时选项 “-r” 会取消所有后缀规则的隐含后缀列表，同样我们可以在 Makefile 中使用 “.SUFFIXES”，定义我们的后缀名的规则。“-r” 选项不会取消 make 内嵌的隐含变量。</td></tr><tr><td>-R，–no-builtin-variabes</td><td>取消 make 内嵌的隐含变量，不过我们可以在 Makefile 中明确定义某些变量。注意：“-R” 和 “-r” 选项同时打开，因为没有了隐含变量，所以隐含规则将失去意义。</td></tr><tr><td>-s，–silent，–quiet</td><td>取消命令执行过程中的打印。</td></tr><tr><td>-S，–no-keep-going， --stop</td><td>取消 “-k” 的选项在递归的 make 过程中子 make 通过 “MAKEFLAGS” 变量继承了上层的命令行选项那个。我们可以在子 make 中使用“-S”选项取消上层传递的 “-k” 选项，或者取消系统环境变量 “MAKEFLAGS” 中 &quot;-k&quot;选项。</td></tr><tr><td>-t，–touch</td><td>和 Linux 的 touch 命令实现功能相同，更新所有的目标文件的时间戳到当前系统时间。防止 make 对所有过时目标文件的重建。</td></tr><tr><td>-v，version</td><td>查看make的版本信息。</td></tr><tr><td>-w，–print-directory</td><td>在 make 进入一个子目录读取 Makefile 之前打印工作目录，这个选项可以帮助我们调试 Makefile，跟踪定位错误。使用 “-C” 选项时默认打开这个选项。</td></tr><tr><td>–no-print-directory</td><td>取消 “-w” 选项。可以是 用在递归的 make 调用的过程中 ，取消 “-C” 参数的默认打开 “-w” 的功能。</td></tr><tr><td>-W FILE，–what-if=FILE， --new-file=FILE， --assume-file=FILE</td><td>设定文件 “FILE” 的时间戳为当前的时间，但不更改文件实际的最后修改时间。此选项主要是为了实现对所有依赖于文件 “FILE” 的目标的强制重建。</td></tr><tr><td>–warn-undefined-variables</td><td>在发现 Makefile 中存在没有定义的变量进行引用时给出告警信息。此功能可以帮助我们在调试一个存在多级嵌套变量引用的复杂 Makefile。但是建议在书写的时候尽量避免超过三级以上的变量嵌套引用。</td></tr></tbody></table><h3 id="常用的参数" tabindex="-1"><a class="header-anchor" href="#常用的参数" aria-hidden="true">#</a> 常用的参数</h3><ul><li><code>-p</code> : 输出 Makefile 所有信息包括规则和变量，可以和 <code>-q</code> 不执行命令结合</li><li><code>-B</code> : 所有目标都需要更新、重新编译</li><li><code>-d</code>：相当于 <code>make -debug=a</code> 输出所有的调试信息。（会非常的多）</li><li><code>-w</code>：输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</li></ul><h2 id="补充-makefile-go语言交叉编译" tabindex="-1"><a class="header-anchor" href="#补充-makefile-go语言交叉编译" aria-hidden="true">#</a> 补充：Makefile Go语言交叉编译</h2><p>我们很多时候都需要实现交叉编译，尤其是对于 Go语言 来说，这一点也很重要。</p><p>我们平常都很喜欢用 Makefile 管理</p><h3 id="获取版本号" tabindex="-1"><a class="header-anchor" href="#获取版本号" aria-hidden="true">#</a> 获取版本号</h3><p>Go语言中获取版本的方法可以使用 <code>go env GOOS</code></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>❯ go <span class="token function">env</span> GOOS
linux
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>同样的我们可以获取到指令集：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>❯ go <span class="token function">env</span> GOARCH
amd64
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>那么在 Makefile 中我们使用 shell 的方式获取：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>GOOS ?<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>shell go <span class="token function">env</span> GOOS<span class="token variable">)</span></span>
GOARCH ?<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>shell go <span class="token function">env</span> GOARCH<span class="token variable">)</span></span>

build:
	go build <span class="token parameter variable">-o</span> out/greeting-<span class="token variable"><span class="token variable">$(</span>GOOS<span class="token variable">)</span></span>-<span class="token variable"><span class="token variable">$(</span>GOARCH<span class="token variable">)</span></span> <span class="token builtin class-name">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="实现交叉编译" tabindex="-1"><a class="header-anchor" href="#实现交叉编译" aria-hidden="true">#</a> 实现交叉编译</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>buildx:
	<span class="token assign-left variable">GOOS</span><span class="token operator">=</span>dorwin <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>amd64 <span class="token function">make</span> build
	<span class="token assign-left variable">GOOS</span><span class="token operator">=</span>dorwin <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>arm64 <span class="token function">make</span> build
	<span class="token assign-left variable">GOOS</span><span class="token operator">=</span>linux <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>amd64 <span class="token function">make</span> build
	<span class="token assign-left variable">GOOS</span><span class="token operator">=</span>linux <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>arm64 <span class="token function">make</span> build	
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>GOOS=linux GOARCH=arm64 </code> 只是在当前那一hang</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p><strong>规范的 Makefile 文件需要的步骤：</strong></p><ol><li>v首先，你需要熟练掌握 Makefile 的语法。我建议你重点掌握以下语法：Makefile 规则语法、伪目标、变量赋值、特殊变量、自动化变量。</li><li>接着，我们需要提前规划 Makefile 要实现的功能。一个大型 Go 项目通常需要实现以下功能：代码生成类命令、格式化类命令、静态代码检查、 测试类命令、构建类命令、Docker 镜像打包类命令、部署类命令、清理类命令，等等。</li><li>然后，我们还需要通过 Makefile 功能分类、文件分层、复杂命令脚本化等方式，来设计一个合理的 Makefile 结构。</li><li>最后，我们还需要掌握一些 Makefile 编写技巧，例如：善用通配符、自动变量和函数；编写可扩展的 Makefile；使用带层级的命名方式，等等。通过这些技巧，可以进一步保证我们编写出一个高质量的 Makefile。</li></ol><h2 id="end-链接" tabindex="-1"><a class="header-anchor" href="#end-链接" aria-hidden="true">#</a> END 链接</h2><ul><li><div><a href="6.md" style="float:left;">⬆️上一节🔗 </a><a href="8.md" style="float:right;"> ️下一节🔗</a></div></li></ul><ul><li><p><a href="/iam/" class="">Ⓜ️回到目录🏠</a></p></li><li><p><a href="https://nsddd.top/archives/contributors" target="_blank" rel="noopener noreferrer"><strong>🫵参与贡献💞❤️‍🔥💖</strong><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>)</p></li><li><p>✴️版权声明 © ：本书所有内容遵循<a href="http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="noopener noreferrer">CC-BY-SA 3.0协议（署名-相同方式共享）©<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></li></ul><h3 id="links" tabindex="-1"><a class="header-anchor" href="#links" aria-hidden="true">#</a> LInks</h3><ul><li>https://time.geekbang.org/column/article/389115</li><li>https://github.com/cubxxw/iam/blob/master/Makefile</li><li>https://seisman.github.io/how-to-write-makefile/rules.html</li><li>https://colynn.github.io/2020-03-03-using_makefile/</li></ul></div><!--[--><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/kubecub/docs/edit/main/docs/iam/projects/7.md" rel="noopener noreferrer" target="_blank" aria-label="在GitHub上贡献此页面"><!--[--><!--]--> 在GitHub上贡献此页面 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 3293172751nss@gmail.com">Xinwei Xiong</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/iam/projects/6.html" class="" aria-label="第6节 API 风格设计"><!--[--><!--]--> 第6节 API 风格设计 <!--[--><!--]--></a></span><span class="next"><a href="/iam/projects/8.html" class="" aria-label="第8节 IAM 项目如何进行研发流程管理"><!--[--><!--]--> 第8节 IAM 项目如何进行研发流程管理 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.9967c189.js" defer></script>
  </body>
</html>
